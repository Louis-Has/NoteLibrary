### new 和 make 的区别

首先我们得知道，Go分为数据类型分为值类型和引用类型，其中

- 值类型是 int、float、string、bool、struct和array，它们直接存储值，分配栈的内存空间，它们被函数调用完之后会释放
- 引用类型是 slice、map、chan和值类型对应的指针 它们存储是一个地址（或者理解为指针）,指针指向内存中真正存储数据的首地址，内存通常在堆分配，通过GC回收

#### 区别

1. new 的参数要求传入一个类型，而不是一个值，它会申请该类型的内存大小空间，并初始化为对应的零值，返回该指向类型空间的一个指针
2. make 也用于内存分配，但它只用于引用对象 slice、map、channel的内存创建，返回的类型是类型本身

### 值传递和指针传递

值传递：会创建一个新的副本并将其传递给所调用函数或方法 指针传递：将创建相同内存地址的新副本

需要改变传入参数本身的时候用指针传递，否则值传递

另外，如果函数内部返回指针，会发生内存逃逸

### 内存逃逸分析

Go的逃逸分析是一种确定指针动态范围的方法，可以分析程序在哪些可以访问到指针，它涉及到指针分析和状态分析。

**当一个变量（或对象）在子程序中被分配时，一个指向变量的指针可能逃逸到其它程序，或者去调用子程序。** 如果使用尾递归优化（通常函数式编程是需要的），对象也可能逃逸到被调用程序中。如果一个子程序分配一个对象并返回一个该对象的指针，该对象可能在程序中的任何一个地方都可以访问。

如果指针存储在全局变量或者其它数据结构中，它们也可能发生逃逸，这种情况就是当前程序的指针逃逸。逃逸分析需要确定指针所有可以存储的地方，保证指针的生命周期只在当前进程或线程中。

导致内存逃逸的情况比较多（有些可能官方未能够实现精确的逃逸分析情况的bug），通常来讲就是如果变量的作用域不会扩大并且行为或者大小能够在其编译时确定，一般情况下都分配栈上，否则就可能发生内存逃逸到堆上。

引用内存逃逸的典型情况： * **在函数内部返回把局部变量指针返回** 局部变量原本应该在栈中分配，在栈中回收。但是由于返回时被外部引用，因此生命周期大于栈，则溢出

-   **发送指针或带有指针的值到channel中** 在编译时，是没办法知道哪个 goroutine 会在 channel上接受数据，所以编译器没办法知道变量什么时候释放。  
    
-   **在一个切片上存储指针或带指针的值** 一个典型的例子就是 []*string，这会导致切片的内容逃逸，尽管其后面的数组在栈上分配，但其引用值一定是在堆上  
    
-   **slice 的背后数组被重新分配了** 因为 append 时可能会超出其容量( cap )。 slice 初始化的地方在编译时是可以知道的，它最开始会在栈上分配。如果切片背后的存储要基于运行时的数据进行扩充，就会在堆上分配。  
    
-   **在 interface 类型上调用方法** 在 interface 类型上调用方法都是动态调度的 —— 方法的真正实现只能在运行时知道。想像一个 io.Reader 类型的变量 r , 调用 r.Read(b) 会使得 r 的值和切片b 的背后存储都逃逸掉，所以会在堆上分配。



### 内存管理

#### 内存池概述

Go语言的内存分配器采用了跟 **tcmalloc** 库相同的实现，是一个带内存池的分配器，底层直接调用操作系统的 mmpa 等函数。

作为一个内存池，它的基本部分包括以下几部分：

-   首先，它会想操作系统申请大块内存，自己管理这部分内存  
    
-   然后，它是一个池子，当上层释放内存时它不实际归还给操作系统，而是放回池子重复利用  
    
-   接着，内存管理中必然会考虑的就是内存碎片问题，如果尽量避免内存碎片，提高内存利用率，像操作系统中的首次适应，最佳适应，最差适应，伙伴算法都是一些相关的知识背景。  
    
-   另外，Go语言是一个支持 goroutine 这种多线程的语言，所以它的内存管理系统必须要考虑在多线程下的稳定性和效率问题。  
    

#### 在多线程方面

很自然的做法就是每条线程都有自己的本地的内存，然后有一个全局的分配链，当某个线程中的内存不足后就向全局分配链中申请内存。这样就避免了多线程同时访问共享变量的加锁。

在避免内存碎片方面，大块内存直接按页为单位分配，小块内存会切成各种不同的固定大小的块，申请做任意字节内存时会向上取整到最接近的块，将整块分配给申请者以避免随意切割。

#### 在避免内存碎片方面

大块内存直接按页为单位分配，小块内存会切成各种不同的固定大小的块，申请做任意字节内存时会向上取整到最接近的块，将整块分配给申请者以避免随意切割。

Go语言中为每个系统线程分配一个本地的 MCahe，少量的地址分配就直接从 MCache 中分配，并且定期做垃圾回收，将线程的 MCache 中的空闲内存返回给全局控制堆。小于 32K为小对象，大对象直接从全局控制堆上以页（4k）为单位进行分配，也就是说大对象总是以页对齐的。一个页可以存入一些相同大小的小对象，小对象从本地内存链表中分配，大对象从中心内存对分配。

大约有 100 种内存块类别，每一个类别都有自己对象的空闲链表。小于 32KB 的内存分配被向上取整到对应的尺寸类别，从相应的空闲链表中分配。一页内存只可以被分裂成同一种尺寸类别的对象，然后由空间链表分配管理器。

大约有 100 种内存块类别，每一个类别都有自己对象的空闲链表。小于 32kB 的内存分配被向上取整到对应的尺寸类别，从相应的空闲链表中分配。一页内存只可以被分裂成同一种尺寸类别的对象，然后由空闲链表分配器管理。

分配器的数据结构包括: _FixAlloc：固定大小（128kB）的对象的空闲链分配器，被分配器用于管理存储；_ MHeap：分配堆，按页的粒度进行管理（4kB）； _MSpan：一些由 MHeap 管理的页；_ MCentral：对于给定尺寸类别的共享的 free list； * MCache：用于小对象的每 M 一个的 cache。

我们可以将Go语言的内存管理看成一个两级的内存管理结构 MHeap 和 MCache。上面一级管理的基本单位是页，用于分配大对象，每次分配都是若干连续的页，也就是若干个 4KB 的大小。使用的数据结构是 MHeap 和 MSpan，用 BestFit 算法做分配，用位示图做回收。下面一级管理的基本单位是不同类型的固定大小的对象，更像一个对象池而不是内存池，用引用计数做回收。下面这一级使用的数据结构是 MCache。

### 线程有几种模型？Goroutine 的原理你了解过吗，将一下实现和原理

### 在GPM调度模型，goroutine 有哪几种状态？线程呢？

### Goroutine中内存泄漏的发现与排查

### Go数据竞争怎么解决





参考文章：
1. [常见Go语言的面试题](https://zhuanlan.zhihu.com/p/360306642)