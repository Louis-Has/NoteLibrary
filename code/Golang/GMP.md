### 协程来提高CPU利用率

线程(thread)
协程(co-routine)
	线程由CPU调度是抢占式的，*协程由用户态调度是协作式的*，一个协程让出CPU后，才执行下一个协程。

### Go语言的协程goroutine

**Go为了提供更容易使用的并发方法，使用了goroutine和channel**。goroutine来自协程的概念，让一组可复用的函数运行在一组线程之上，即使有协程阻塞，该线程的其他协程也可以被`runtime`调度，转移到其他可运行的线程上。最关键的是，程序员看不到这些底层的细节，这就降低了编程的难度，提供了更容易的并发。

Go中，协程被称为goroutine，它非常轻量，一个goroutine只占几KB，并且这几KB就足够goroutine运行完，这就能在有限的内存空间内支持大量goroutine，支持了更多的并发。虽然一个goroutine的栈只占几KB，但实际是可伸缩的，如果需要更多内容，`runtime`会自动为goroutine分配。

### Goroutine调度器的GMP模型

![[GMP.png]]

1.  G — 表示 Goroutine，它是一个待执行的任务；
	1. Goroutine 是 Go 语言调度器中待执行的任务，它在运行时调度器中的地位与线程在操作系统中差不多，但是它占用了更小的内存空间，也降低了上下文切换的开销。
	2. Goroutine 只存在于 Go 语言的运行时，它是 **Go 语言在用户态提供的线程，作为一种粒度更细的资源调度单元**，如果使用得当能够在高并发的场景下更高效地利用机器的 CPU。

2.  M — 表示操作系统的线程，它由操作系统的调度器调度和管理；
	1. 在默认情况下，运行时会将 `GOMAXPROCS` 设置成当前机器的核数，我们也可以在程序中使用 **runtime.GOMAXPROCS** 来改变最大的活跃线程数。

3.  P — 表示处理器，它可以被看做运行在线程上的本地调度器；
	1. 调度器中的处理器 P 是**线程和 Goroutine 的中间层**，它能**提供线程需要的上下文环境**，也会**负责调度线程上的等待队列**，通过处理器 P 的调度，每一个内核线程都能够执行多个 Goroutine，它能在 Goroutine 进行一些 I/O 操作时及时让出计算资源，提高线程的利用率。
	2. 因为调度器在启动时就会创建 `GOMAXPROCS` 个处理器，所以 Go 语言程序的**处理器数量一定会等于 `GOMAXPROCS`**，这些处理器会绑定到不同的内核线程上。


