
### -`GC`，全称 `Garbage Collection`，即垃圾回收，是一种自动内存管理的机制。

通常，垃圾回收器的执行过程被划分为两个半独立的组件：
-   赋值器（Mutator）：这一名称本质上是在指代用户态的代码。因为*对垃圾回收器而言，用户态的代码仅仅只是在修改对象之间的引用关系*，也就是在对象图（对象之间引用关系的一个有向图）上进行操作。
-   回收器（Collector）：负责执行垃圾回收的代码。

### 根对象

根对象在垃圾回收的术语中*又叫做根集合，它是垃圾回收器在标记过程时最先检查的对象*，包括：

1.  全局变量：程序在编译期就能确定的那些存在于程序整个生命周期的变量。
2.  执行栈：*每个 goroutine 都包含自己的执行栈*，这些执行栈上包含栈上的变量及指向分配的堆内存区块的指针。
3.  寄存器：寄存器的值可能表示一个指针，参与计算的这些指针可能指向某些赋值器分配的堆内存区块。

### STW

`STW` 可以是 `Stop the World` 的缩写，也可以是 `Start the World` 的缩写。通常意义上指*指代从 `Stop the World` 这一动作发生时到 `Start the World` 这一动作发生时这一段时间间隔*，即万物静止。STW 在垃圾回收过程中为了保证实现的正确性、防止无止境的内存增长等问题而不可避免的需要停止赋值器进一步操作对象图的一段过程。

### GC 实现方式

#### -   追踪式 GC

    从根对象出发，根据对象之间的引用信息，一步步推进直到扫描完毕整个堆并确定需要保留的对象，从而回收所有可回收的对象。Go、 Java、V8 对 JavaScript 的实现等均为追踪式 GC。

#### -   引用计数式 GC

    每个对象自身包含一个被引用的计数器，当计数器归零时自动得到回收。因为此方法缺陷较多，在追求高性能时通常不被应用。Python、Objective-C 等均为引用计数式 GC。

#### Go V1.3 标记-清除(mark and sweep)算法

mark and sweep算法在执行的时候，需要程序暂停！即 `STW(stop the world)`，STW的过程中，CPU不执行用户代码，全部用于垃圾回收，这个过程的影响很大，所以STW也是一些回收机制最大的难题和希望优化的点。

#### Go V1.5的三色并发标记法

**第一步** , 每次新创建的对象，默认的颜色都是标记为“白色”
**第二步**, 每次GC回收开始, 会从根节点开始遍历所有对象，把遍历到的对象从白色集合放入“灰色”集合
**第三步**, 遍历灰色集合，将灰色对象引用的对象从白色集合放入灰色集合，之后将此灰色对象放入黑色集合
**第四步**, 重复**第三步**, 直到灰色中无任何对象
**第五步**: 回收所有的白色标记表的对象. 也就是回收垃圾

但是这里面可能会有很多并发流程均会被扫描，执行并发流程的内存可能相互依赖，*为了在GC过程中保证数据的安全*，我们在开始三色标记之前就会加上STW，在扫描确定黑白对象之后再放开STW。

#### 没有STW的三色标记法——屏障机制

(1) “强-弱” 三色不变式
-   强三色不变式
	强制性的不允许黑色对象引用白色对象，这样就不会出现有白色对象被误删的情况。
-   弱三色不变式
	所有被黑色对象引用的白色对象都处于灰色保护状态。

##### 插入屏障
`具体操作`: 在A对象引用B对象的时候，B对象被标记为灰色。(将B挂在A下游，B必须被标记为灰色)
`满足`: **强三色不变式**. (不存在黑色对象引用白色对象的情况了， 因为白色会强制变成灰色)

要对栈重新进行三色标记扫描, 但这次为了对象不丢失, 要对本次标记扫描启动STW暂停. 直到栈空间的三色标记结束.

##### 删除屏障
`具体操作`: 被删除的对象，如果自身为灰色或者白色，那么被标记为灰色。
`满足`: **弱三色不变式**. (保护灰色对象到白色对象的路径不会断)

这种方式的回收精度低，一个对象即使被删除了最后一个指向它的指针也依旧可以活过这一轮，在下一轮GC中被清理掉。

#### Go V1.8的混合写屏障(hybrid write barrier)机制

`具体操作`:

1. GC开始将栈上的对象全部扫描并标记为黑色(之后不再进行第二次重复扫描，无需STW)，
2. GC期间，任何在栈上创建的新对象，均为黑色。
3. 被删除的对象标记为灰色。
4. 被添加的对象标记为灰色。

`满足`: 变形的**弱三色不变式**.

Go V1.8版本引入了混合写屏障机制（hybrid write barrier），避免了对栈re-scan的过程，极大的减少了STW的时间。结合了两者的优点。

### 触发 GC 的时机是什么？

Go 语言中对 GC 的触发时机存在两种形式：

1.  **主动触发**，通过调用 runtime.GC 来触发 GC，此调用阻塞式地等待当前 GC 运行完毕。
    
2.  **被动触发**，分为两种方式：
    
    -   使用系统监控，当超过两分钟没有产生任何 GC 时，强制触发 GC。
        
    -   使用步调（Pacing）算法，其核心思想是控制内存增长的比例。

### Go 的垃圾回收器有哪些相关的 API

-   *runtime.GC*：手动触发 GC
-   *runtime.ReadMemStats*：读取内存相关的统计信息，其中包含部分 GC 相关的统计信息
-   debug.FreeOSMemory：手动将内存归还给操作系统
-   debug.ReadGCStats：读取关于 GC 的相关统计信息
-   debug.SetGCPercent：设置 GOGC 调步变量
-   debug.SetMaxHeap（尚未发布[10]）：设置 Go 程序堆的上限值

### Go 语言的 GC 需要优化的地方

充分考虑*内存分配的必要性*，减少过多申请内存带给垃圾回收器的压力。

峰值流量后，大量 goroutine 由于任务等待被休眠，从而运行时不断创建新的 goroutine， 旧的 goroutine 由于休眠未被销毁且得不到复用，导致 GC 需要扫描的执行栈越来越多，进而完成 GC 所需的时间越来越长。 一个解决办法是*使用 goroutine 池来限制创建的 goroutine 数量*。


参考文章：
1. [垃圾回收的认识](https://golang.design/go-questions/memgc/principal/)
2. [刘丹冰Aceld三色标记混合写屏障](https://www.yuque.com/aceld/golang/zhzanb)