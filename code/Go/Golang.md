1.  struct 匿名字段 嵌入字段 重载字段 method重写
2.  如果不传Box的指针，那么SetColor接受的其实是Box的一个copy，也就是说method内对于颜色值的修改，其实只作用于Box的copy，而不是真正的Box。
3.  goroutine说到底其实就是协程，但是它比线程更小
4.  str,_ := username.(string) 类型断言

### Go面向对象是如何实现

Go 语言虽然没有像其他一些面向对象编程语言那样提供传统的类和继承的概念，但它仍然支持面向对象的编程风格和特性。在 Go 中，面向对象是通过结构体（struct）和方法（method）来实现的。

以下是 Go 语言中实现面向对象的几个关键点：

1. 结构体（struct）：结构体是一种自定义的数据类型，可以用于封装一组相关的数据字段。**结构体可以包含字段和方法**，并可以定义行为和属性。
    
2. 方法（method）：方法是**与结构体关联的函数**，它可以访问结构体的字段和执行特定的操作。方法可以定义在结构体上，也可以定义在非结构体类型上。
    
3. 接口（interface）：接口是一组方法的集合，用于定义对象的行为。接口定义了对象应该具有的方法，并提供了一种约束，实现了接口的类型必须实现接口中定义的所有方法。
    
4. 封装（encapsulation）：封装是一种将数据和相关方法隐藏起来，只允许特定的操作方式来访问和修改数据的机制。在 Go 中，使用**大写字母开头的字段或方法**可以实现对外部的公开访问，小写字母开头的字段或方法则是私有的。
    
5. 继承（inheritance）：Go 语言没有显式的继承机制，但可以通过**嵌入结构体**来实现类似的效果。通过在一个结构体中嵌入另一个结构体，可以继承其字段和方法。
    
6. 多态（polymorphism）：Go 语言通过接口实现了多态的特性。多态允许不同类型的对象对相同的接口进行操作，提高了代码的灵活性和复用性。
    

总的来说，Go 语言的面向对象编程风格通过结构体、方法和接口等机制来实现。虽然与传统的面向对象编程语言有所不同，但它依然提供了一种灵活、简洁和高效的方式来组织和管理代码。

### GO Error
- [Golang 中的错误处理](https://pandaychen.github.io/2022/05/30/HOW-TO-DEAL-WITH-GOLANG-ERRORS/)
- [Golang error 的突围](https://www.cnblogs.com/qcrao-2018/p/11538387.html)

### [Golang 闭包](https://pandaychen.github.io/2023/03/25/A-GOLANG-CLOSURE-USAGE/)
- 是指内层函数引用了外层函数中的变量或称为引用了自由变量的函数，其返回值也是一个函数（方法）
- 特点
	- 闭包能够访问外层代码中的变量
	- `for range` 模式与 goroutine 同时执行
	- 所有的 goroutine 操作的变量都是直接操作外层代码的变量，而外层代码中的变量的值取决于循环执行的节点

### make  new 和 :=  使用区别

`make`：`make` 是一个**用于创建切片、映射和通道的内置函数**。它分配并初始化了底层的数据结构，并返回对应类型的引用（**切片、映射或通道**）。使用 `make` 创建的变量是**对底层数据结构的引用**，而不是变量本身的值。

`new`：`new` 是一个用于**在堆上分配内存**并**返回指向该内存的指针**的内置函数。它接收一个类型作为参数，并**返回该类型的零值**的指针。使用 `new` 创建的变量是指针类型，指向分配在堆上的内存空间。

`:=`（短变量声明）：`:=` 操作符用于**在当前作用域内**声明和初始化变量。它根据右侧表达式的类型推断变量的类型，并进行赋值。`:=` 创建的变量是**在栈上分配**的，并且**只在当前作用域内可见**。

##### 值类型和引用类型

首先我们得知道，Go分为数据类型分为值类型和引用类型，其中

- 值类型是 int、float、string、bool、struct和array，它们直接存储值，分配栈的内存空间，它们被函数调用完之后会释放
- 引用类型是 slice、map、chan和值类型对应的指针 它们存储是一个地址（或者理解为指针）,指针指向内存中真正存储数据的首地址，内存通常在堆分配，通过GC回收

1. new 的参数要求传入一个类型，而不是一个值，它会申请该类型的内存大小空间，并初始化为对应的零值，返回该指向类型空间的一个指针
2. make 也用于内存分配，但它只用于引用对象 slice、map、channel的内存创建，返回的类型是类型本身

### Go什么时候发生阻塞

在 Go 中，阻塞通常发生在以下情况下：

1. 通道操作阻塞：当向一个已满的通道发送数据或从一个空的通道接收数据时，通道操作将会阻塞，直到有足够的空间发送或接收数据。
    
2. 互斥锁阻塞：当使用互斥锁进行临界区保护时，如果某个 goroutine 已经获取了锁并且没有释放，其他想要获取该锁的 goroutine 将会被阻塞，直到锁被释放。
    
3. 等待组阻塞：当使用 `sync.WaitGroup` 进行并发任务的等待时，如果还有未完成的任务，调用 `Wait` 方法会导致当前 goroutine 阻塞，直到所有任务完成。
    
4. 定时器阻塞：当使用定时器函数如 `time.Sleep` 或 `time.After` 等时，调用这些函数将会导致当前 goroutine 阻塞，直到定时器时间到达。
    
5. 文件读写阻塞：当进行文件读写操作时，如果文件没有准备好或无法进行读写，读取或写入操作将会阻塞，直到文件准备好或可读写。
    
6. 网络阻塞：在进行网络通信时，例如使用 `net.Dial` 进行连接、`net.Listen` 进行监听等，这些操作可能会因为网络连接的建立或等待请求的到来而阻塞。
    

需要注意的是，Go 的并发模型使用了 goroutine 和通道来实现轻量级的并发和通信，通常情况下并不会直接涉及到阻塞操作。大部分情况下，使用通道和选择语句等机制可以实现非阻塞的并发操作。但在特定的情况下，可能会发生阻塞，需要根据具体的代码和使用场景来分析和处理阻塞的情况。


### GMP能不能去掉P层？会怎么样？

在 Go 的运行时系统中，GMP（Goroutine、M、P）是一种协作调度模型，用于实现并发执行和调度 goroutine。其中，Goroutine 表示并发执行的轻量级线程，M（Machine）表示内核线程，P（Processor）表示执行 goroutine 的上下文。

P 层的存在是为了**解决 M-N 模型中的线程切换和调度问题**。在 M-N 模型中，M 表示内核线程，N 表示 goroutine。**当一个内核线程中的 goroutine 阻塞时，会导致整个线程无法继续执行其他 goroutine，从而影响并发性能。** 通过引入 P 层，每个 M 可以绑定一个或多个 P，并且每个 P 可以执行多个 goroutine。P 层通过协作调度，使得当一个 goroutine 阻塞时，其他 goroutine 仍然可以继续执行，提高了并发性能和资源利用率。

因此，去掉 P 层会导致运行时系统失去了协作调度的能力，无法在阻塞时切换到其他可运行的 goroutine。这可能导致并发执行的能力下降，同时也会影响系统的资源利用率。因此，去掉 P 层可能会对程序的性能和可扩展性产生负面影响。

总的来说，P 层在 Go 的并发模型中起着重要的作用，去掉 P 层可能会导致运行时系统失去协作调度的能力，从而影响并发性能和资源利用率。因此，不建议去掉 P 层。

### goroutine什么情况会发生内存泄漏？如何避免。

在 Go 中，当 goroutine 的生命周期结束后，如果它持有的资源没有被正确释放，就可能会发生内存泄漏。以下是一些常见的导致内存泄漏的情况和避免方法：

1. 未关闭通道：如果一个 goroutine 向通道发送数据或接收数据后没有及时关闭通道，通道可能会一直阻塞等待，导致内存泄漏。确保在不需要继续发送或接收数据时关闭通道。
    
2. 未释放锁资源：如果在 goroutine 中使用互斥锁或读写锁时，没有在合适的时机释放锁资源，其他 goroutine 将无法获取锁而阻塞，导致内存泄漏。确保在不再需要锁保护的临界区结束后释放锁资源。
    
3. 未释放定时器：如果在 goroutine 中创建了定时器，但没有及时停止或释放定时器，定时器可能会一直运行并触发操作，导致内存泄漏。确保在不需要定时器时停止或释放定时器。
    
4. 未清理资源：如果在 goroutine 中分配了内存或打开了文件、数据库连接等资源，但在 goroutine 结束后没有及时清理和释放这些资源，就会导致内存泄漏。确保在 goroutine 结束时释放和清理分配的资源。
    

为了避免内存泄漏，可以采取以下措施：

1. 使用 defer 关键字：在 goroutine 中使用 defer 关键字来确保在函数退出时执行资源清理操作，例如关闭文件、释放锁等。
    
2. 使用带缓冲的通道：在使用通道进行通信时，如果确定通道的缓冲区大小，可以避免由于通道阻塞而导致的内存泄漏。
    
3. 显式释放资源：对于需要手动分配和释放的资源，确保在不再需要时及时释放，例如使用 defer、deferred close 或 finalizer 来释放资源。
    
4. 使用内存分析工具：可以使用 Go 的内置工具或第三方工具进行内存分析，帮助检测和定位潜在的内存泄漏问题。
    

总之，避免内存泄漏的关键是及时释放不再使用的资源，包括通道、锁、定时器和其他分配的资源。通过良好的资源管理和内存分析，可以减少内存泄漏的风险，并确保应用程序的内存使用效率。

### go竞态

在 Go 中，竞态（Race Condition）指的是多个 goroutine 并发访问共享资源时可能出现的不确定性行为。竞态条件的发生是由于多个 goroutine 同时读写共享资源，而没有进行正确的同步和互斥操作。

竞态条件可能导致程序出现非预期的结果，例如数据不一致、数据丢失、死锁等问题。在竞态条件下，程序的行为变得不可预测，因为每个 goroutine 的执行顺序和时间是不确定的。

为了避免竞态条件，可以采取以下措施：

1. 互斥锁：使用互斥锁（Mutex）或读写锁（RWMutex）来保护共享资源的读写操作。在访问共享资源之前，获取锁，在完成操作后释放锁，以确保同一时间只有一个 goroutine 访问共享资源。
    
2. 原子操作：使用原子操作来对共享资源进行读写，例如原子加减、原子交换等。原子操作能够确保多个 goroutine 对共享资源的操作是原子性的，避免了竞态条件的发生。
    
3. 通道通信：使用通道进行数据传递和同步，避免直接对共享资源进行读写操作。通过发送和接收操作来实现数据的同步和协调，保证每个操作的顺序和执行时机。
    
4. 等待组：使用等待组（WaitGroup）来协调多个 goroutine 的执行顺序和同步，确保某个操作在其他操作完成之后再执行。
    
5. 原子性检测工具：使用 Go 提供的原子性检测工具，例如 go run -race 命令或使用第三方竞态检测工具，来检测和分析潜在的竞态条件问题。
    

总之，避免竞态条件的关键是确保对共享资源的访问是同步和互斥的。通过合适的锁、原子操作、通道通信和同步机制，可以保证程序的正确性和可靠性，避免竞态条件带来的问题。

### panic（使用多值返回来返回错误
1. 函数立刻停止执行 (注意是函数本身，不是应用程序停止)
2. defer函数被执行
3. 返回给调用者(caller)
4. 调用者函数假装也收到了一个panic函数，从而  
	1. 立即停止执行当前函数  
	2. 它defer函数被执行  
	3. 返回给它的调用者(caller)
5. ...(递归重复上述步骤，直到最上层函数)  
    应用程序停止。
6. panic的行为

### log.Fatal
1. 打印输出内容
2. 退出应用程序
3. defer函数不会执行

### slice，len，cap，共享，扩容
- 当slice的`len==cap`后，再向slice中追加元素时，会发生扩容
- [你不知道的 Go 之 slice](https://darjun.github.io/2021/05/09/youdontknowgo/slice/)

### map如何顺序读取
- map底层使用hash表实现,插入数据位置是随机的
- 将 map 的 key 全部拿出来，放到一个数组中，
- 然后对这个数组排序后对有序数组遍历，再间接取 map 里的值

### 实现set
- set := make(map[string]void)

### fmt.Printf 的 格式化占位符

1. `%v`：通用的格式化占位符，根据值的类型选择合适的默认格式。
2. `%+v`：输出结构体各成员的**名称**和**值**；
3. `%#v`：输出结构体名称和结构体各成员的名称和值
4. `%s`：字符串。
5. `%t`：布尔值，打印 `true` 或 `false`。
6. `%T`：于打印值的类型信息

### go struct能不能比较

在 Go 语言中，结构体是可比较的，前提是结构体的字段都是可比较的类型。

可比较的类型包括基本类型（如整数、浮点数、布尔值等）、字符串、指针、数组、切片和结构体。如果**结构体的所有字段都是可比较的类型**，并且**字段的类型和顺序在两个结构体中完全相同**，并且**对应字段的值也相等**，那么这两个结构体就是**可比较且相等**的。

需要注意的是，如果**结构体中包含不可比较的类型，如切片、映射或函数等**，或者结构体中包含指针类型的字段，那么比较操作**将会引发编译错误**。如果需要深度比较结构体，可以使用其他库或自定义函数来实现。

综上所述，结构体是可比较的，但需要注意字段类型的可比较性和字段值的相等性。

- reflect.DeepEqual 函数用来判断两个值是否深度一致

### go defer（for defer）
- 被defer的函数执行顺序满足LIFO原则，后defer的先执行。
- 被`defer`的函数或者方法如果存在多级调用，只有最后一个函数或方法会被`defer`到函数return或者panic之前执行
- 被defer的函数或方法的参数的值在执行到defer语句的时候就被确定下来了。
- defer后面跟的必须是函数或者方法调用，defer后面的表达式不能加括号。
- 被defer的函数可以对defer语句所在的函数的命名返回值做读取和修改操作。

### 主协程如何等其余协程完再操作
- wg sync.WaitGroup
	- wg.Add(2)
	- wg.Done()
	- wg.Wait()

### select可以用于什么
- -   `select` 主要用于**监听多个`channel`是否可以收发消息**，`select会尝试执行case语句`。当任何一个case满足条件则会执行，若没有可执行的case，就会执行**default分支**。如果default也不满足，程序会跳出select语句块。

### context包的用途
- 主要用来在 goroutine 之间**传递上下文信息**，包括：请求特定数据、取消信号以及处理请求的截止日期。在多个 Goroutine 组成的树中同步取消信号以减少对资源的消耗和占用。
- 协程之间：需要共享一些全局变量、有共同的 deadline 等，而且可以同时被关闭。
- [Context](https://www.topgoer.cn/docs/golang/chapter11-10)

### Go 语言 tag 的用处

在Go语言中，结构体字段的tag是用于为结构体字段附加元数据的一种机制。它以反引号包裹的字符串形式出现在结构体字段的声明后面，如`json:"name"`。

结构体字段的tag在编译期间可以被反射机制读取和解析，常用于以下场景：

1. 序列化和反序列化：常见的使用是在进行JSON、XML等格式的序列化和反序列化时，使用tag指定字段与序列化后的名称之间的映射关系。比如，可以使用`json:"name"`来指定某个字段在JSON中的名称。
    
2. 数据校验和验证：可以使用tag来指定字段的校验规则和约束条件。一些第三方库和框架可以根据tag定义的校验规则对结构体进行验证，比如检查字段的长度、数据类型等。
    
3. ORM映射：在使用ORM（对象关系映射）库时，可以使用tag来指定结构体字段与数据库表字段之间的映射关系，比如表名、列名、主键等。
    
4. API文档生成：一些API文档生成工具可以根据结构体字段的tag生成相应的API文档，包括字段的描述、类型、示例值等。
    

总之，结构体字段的tag为开发者提供了一种扩展和附加元数据的机制，可以在运行时通过反射读取和解析这些tag，用于实现各种功能和处理逻辑。

### 如何获取一个结构体的所有tag

```go
type User struct {
	ID   int    `json:"id"`
	Name string `json:"name"`
	Age  int    `json:"age"`
}

func main() {
	user := User{
		ID:   1,
		Name: "John Doe",
		Age:  30,
	}

	// 获取结构体类型
	userType := reflect.TypeOf(user)

	// 遍历结构体的字段
	for i := 0; i < userType.NumField(); i++ {
		field := userType.Field(i)

		// 获取字段的tag
		tag := field.Tag

		// 打印字段名和对应的tag值
		fmt.Printf("Field: %s, Tag: %s\n", field.Name, tag)
	}
}

```

### 函数返回局部变量的指针

	局部变量在函数返回后会被销毁，而返回指向已被销毁的局部变量的指针可能会导致访问无效的内存。

- 如果需要在函数之外使用局部变量的值，可以考虑使用返回值而不是指针。
	- Go会进行**逃逸分析**，如果发现局部变量的作用域超过该函数则会**把指针分配到堆区**，避免内存泄漏。
- 确实需要返回指向局部变量的指针，可以通过动态分配内存来避免访问无效的内存。例如，使用 `new` 或 `make` 函数创建堆上的变量，并返回指向该堆上变量的指针。


### uint 溢出问题怎么办

在 Go 语言中，`uint` 是无符号整数类型，它的取值范围是从 0 到 `math.MaxUint`。当进行计算或赋值操作时，如果超出了 `uint` 的取值范围，会发生溢出。

处理 `uint` 溢出的方法取决于具体的应用场景和需求。以下是一些处理 `uint` 溢出的常见方法：

1. 检查溢出：在进行计算之前，可以先检查操作数的范围，并确保不会导致溢出。例如，可以使用条件语句或比较操作符检查计算结果是否超过了 `math.MaxUint`。
    
2. 使用更大的整数类型：如果 `uint` 的范围不足以满足需求，可以考虑使用更大的整数类型，如 `uint64`。这样可以扩展取值范围，并避免溢出问题。注意，在使用更大的整数类型时，需要确保与其他相关代码的兼容性。
    
3. 使用溢出检测和处理函数：Go 语言标准库提供了一些处理溢出的函数，如 `math.SafeAdd`、`math.SafeSub`、`math.SafeMul` 等。这些函数可以进行溢出检测，并采取适当的措施来处理溢出情况。
    
4. 使用溢出安全的库：除了标准库提供的函数外，还有一些第三方库专门用于处理整数溢出问题。这些库提供了更丰富的功能和处理方式，可以根据具体需求选择合适的库来处理溢出问题。
    

需要注意的是，在处理溢出时，应根据具体的业务逻辑和需求来选择合适的处理方式。对于关键的计算和数据操作，建议进行严格的溢出检查和处理，以确保程序的正确性和安全性。



### 参考文章：
1. [常见Go语言的面试题](https://zhuanlan.zhihu.com/p/360306642)