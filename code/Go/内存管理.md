
程序中的数据和变量都会被分配到程序所在的虚拟内存中，内存空间**包含两个重要区域：栈区（Stack）和堆区（Heap）**。函数调用的参数、返回值以及局部变量大都会被分配到栈上，这部分内存会由编译器进行管理；不同编程语言使用不同的方法管理堆区的内存，C++ 等编程语言会由工程师主动申请和释放内存，Go 以及 Java 等编程语言会由工程师和编译器共同管理，堆中的对象由内存分配器分配并由垃圾收集器回收。

内存分配根据 span，central 和 heap 分为三个层级，按是否大于 32 KiB 决定是否直接透过 Page 在堆上分配。

### 设计原理

内存管理一般包含三个不同的组件，分别是**用户程序（Mutator）**、**分配器（Allocator）** 和**收集器（Collector）**，当用户程序申请内存时，它会通过内存分配器申请新内存，而分配器会负责从堆中初始化相应的内存区域。

### 虚拟内存布局

这里会介绍 Go 语言堆区内存地址空间的设计以及演进过程，在 Go 语言 1.10 以前的版本，堆区的内存空间都是连续的；但是在 1.11 版本，Go 团队使用稀疏的堆内存空间替代了连续的内存，解决了连续内存带来的限制以及在特殊场景下可能出现的问题。

...

### [逃逸分析](https://zhuanlan.zhihu.com/p/145468000)

`golang程序变量`会携带有一组校验数据，用来证明它的整个生命周期是否在运行时完全可知。如果变量通过了这些校验，它就可以在`栈上`分配。否则就说它 `逃逸` 了，必须在`堆上分配`。

-   **在方法内把局部变量指针返回** 局部变量原本应该在栈中分配，在栈中回收。但是由于返回时被外部引用，因此其生命周期大于栈，则溢出。
-   **发送指针或带有指针的值到 channel 中。** 在编译时，是没有办法知道哪个 goroutine 会在 channel 上接收数据。所以编译器没法知道变量什么时候才会被释放。
-   **在一个切片上存储指针或带指针的值。** 一个典型的例子就是 []*string 。这会导致切片的内容逃逸。尽管其后面的数组可能是在栈上分配的，但其引用的值一定是在堆上。
-   **slice 的背后数组被重新分配了，因为 append 时可能会超出其容量( cap )。** slice 初始化的地方在编译时是可以知道的，它最开始会在栈上分配。如果切片背后的存储要基于运行时的数据进行扩充，就会在堆上分配。
-   **在 interface 类型上调用方法。** 在 interface 类型上调用方法都是动态调度的 —— 方法的真正实现只能在运行时知道。想像一个 io.Reader 类型的变量 r , 调用 r.Read(b) 会使得 r 的值和切片b 的背后存储都逃逸掉，所以会在堆上分配。

在编译器优化中，逃逸分析是用来**决定指针动态作用域**的方法。Go 语言的编译器**使用逃逸分析决定哪些变量应该在栈上分配，哪些变量应该在堆上分配**，其中包括使用 `new`、`make` 和字面量等方法隐式分配的内存，Go 语言的逃逸分析遵循以下两个不变性：

1.  指向栈对象的指针不能存在于堆中；
2.  指向栈对象的指针不能在栈对象回收后存活；


参考文章：
1. [Go语言设计与实现](https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-stack-management/)