

### 内存分配

Go 语言的内存分配是由运行时系统（runtime）负责管理的，开发者无需显式地进行内存分配和释放操作。以下是关于 Go 内存分配的一些重要信息：

1. 堆（Heap）分配：Go 语言**使用堆来动态分配大型对象和变量**。堆上的内存由**垃圾回收器**（Garbage Collector）进行管理，它负责检测不再使用的对象，并回收其内存供后续重用。开发者可以使用 `new` 或 `make` 关键字来在堆上分配内存，例如 **`new(Type)`** 和 **`make(Type)`**，其中 `Type` 是要分配的类型。
    
2. 栈（Stack）分配：Go 语言**使用栈来存储函数调用的局部变量和函数调用的上下文信息**。栈内存的分配和释放是由编译器自动管理的，它具有自动分配和回收的特性。每个 Goroutine（Go 语言的并发执行单位）都有自己的栈空间，用于存储函数调用时的局部变量和函数调用的上下文信息。
    
3. 值类型和引用类型：在 Go 语言中，变量可以是值类型或引用类型。值类型的变量**直接存储其值**，通常在栈上分配内存。引用类型的变量**存储的是指向底层数据的引用**，而底层数据则通常在堆上分配内存。当值类型的变量被传递给函数时，会进行一次值的拷贝，而引用类型的变量则会传递引用。
    

需要注意的是，Go 语言的自动内存管理机制会根据需要进行内存分配和回收，但并不代表它是完全无成本的。因此，在编写代码时，仍然需要注意避免内存泄漏和不必要的内存分配，例如避免创建过多的临时对象，及时释放资源等，以提高程序的性能和效率。


### 垃圾回收

##### [Golang三色标记混合写屏障GC模式全分析](obsidian://open?vault=NoteLibrary&file=code%2FGo%2F%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6)

在 Go 语言中，垃圾回收（Garbage Collection）是自动进行的，由运行时系统负责管理。Go 的垃圾回收机制帮助开发者管理内存，自动回收不再使用的对象，从而减轻了手动内存管理的负担。

Go 的垃圾回收器的工作原理如下：

1. 标记-清除算法：Go 语言使用标记-清除算法进行垃圾回收。该算法分为两个阶段：标记阶段和清除阶段。
    
    - 标记阶段：垃圾回收器从根对象（如全局变量、活跃的 Goroutine 栈等）开始，标记所有可达的对象，即那些仍然被引用的对象。标记的过程是通过遍历对象引用关系图来完成的。
        
    - 清除阶段：垃圾回收器从堆的起始位置开始，扫描整个堆，将未被标记的对象视为垃圾，将其所占用的内存回收。
        
2. 并发回收：Go 的垃圾回收器采用并发的方式进行工作，即在主线程执行程序的同时，垃圾回收器在后台进行垃圾回收操作。这样可以减少对程序性能的影响。
    
3. 分代回收：Go 的垃圾回收器采用分代回收策略。它将堆内存划分为几个不同的代（Generation），每个代都有自己的回收周期。新分配的对象会被分配到较新的代中，而经过多次回收仍然存活的对象会被晋升到下一代。
    

Go 语言的垃圾回收器使用**智能指针**（Smart Pointers）和**写屏障**（Write Barrier）等技术来提高垃圾回收的效率和准确性。它会根据需要进行内存分配和回收，并在程序执行期间动态调整垃圾回收的策略，以达到最佳的性能和资源利用。

开发者无需手动管理内存，也无需显式地触发垃圾回收操作。然而，为了编写高效的代码，可以遵循一些良好的内存管理实践，例如避免创建过多的临时对象、及时释放资源等，以帮助垃圾回收器更好地工作。


### 栈空间管理

在 Go 语言中，栈（Stack）是用于**存储函数调用的局部变量和函数调用的上下文信息**的内存区域。Go 的栈空间管理由编译器和运行时系统（runtime）共同负责。

栈空间管理的主要原则和特点如下：

1. 自动分配和释放：栈上的内存分配和释放是自动进行的，由编译器和运行时系统负责。在函数调用时，栈会自动为函数的局部变量分配内存，而**在函数返回后，这些局部变量所占用的内存会被自动释放。**
    
2. 固定大小：每个 **Goroutine**（Go 语言的并发执行单位）都有自己的栈空间，栈的大小是固定的，通常在几兆字节的量级。栈的大小在程序启动时就确定了，并且是在编译时指定的。
    
3. 后进先出：栈是一种后进先出（Last In, First Out）的数据结构，每个函数的局部变量都会被压入栈顶，而在函数返回时则从栈顶弹出。
    
4. 有限深度：由于栈的大小是有限的，当栈空间不足以存储更多的函数调用时，就会发生栈溢出（Stack Overflow）错误。
    

在编写代码时，开发者无需直接操作栈空间，栈的分配和释放是由编译器和运行时系统自动完成的。开发者只需关注函数的实现和正确使用局部变量，而无需关心栈的具体管理细节。这种自动化的栈空间管理机制使得 Go 语言具有更简洁、更安全的函数调用和内存管理方式。


#### 逃逸分析

逃逸分析（Escape Analysis）是 Go 语言编译器的一项优化技术，用于确定程序中的对象在编译时是否会逃逸到堆上分配内存。逃逸分析的**主要目的是在编译阶段确定对象的生命周期和分配位置**，从而**优化内存分配和减少垃圾回收的压力**。

逃逸分析的基本原理是分析程序中对象的引用关系，判断对象是否会逃逸到函数的外部。如果对象逃逸到函数的外部，意味着对象的生命周期超出了函数的范围，需要在堆上分配内存；如果对象在函数内部使用，并且不会被外部引用，可以在栈上分配内存，避免堆上的内存分配和垃圾回收。

逃逸分析的优化效果包括：

1. 栈上分配：当对象不逃逸时，可以直接在栈上分配内存，避免了堆上的内存分配和垃圾回收，提高了程序的执行效率。
    
2. 栈帧复用：逃逸分析可以确定对象的生命周期，当对象的作用域结束时，可以直接将栈帧复用，而无需等待垃圾回收器回收对象。
    
3. 内联优化：逃逸分析可以确定函数调用中对象的逃逸情况，从而帮助编译器进行内联优化，减少函数调用的开销。
    

逃逸分析是**在编译阶段进行**的，由编译器自动完成，开发者无需手动干预。在大多数情况下，逃逸分析能够有效地优化内存分配和减少垃圾回收的压力，提升程序的性能。然而，在某些特殊情况下，逃逸分析可能会产生不准确的结果，导致性能下降。在这种情况下，可以通过手动干预代码，如使用 `unsafe` 包等方式来进行优化。

##### 典型情况

能引起变量逃逸到堆上的**典型情况**：
-   **在方法内把局部变量指针返回** 局部变量原本应该在栈中分配，在栈中回收。但是由于返回时被外部引用，因此其生命周期大于栈，则溢出。
-   **发送指针或带有指针的值到 channel 中。** 在编译时，是没有办法知道哪个 goroutine 会在 channel 上接收数据。所以编译器没法知道变量什么时候才会被释放。
-   **在一个切片上存储指针或带指针的值。** 一个典型的例子就是 []*string 。这会导致切片的内容逃逸。尽管其后面的数组可能是在栈上分配的，但其引用的值一定是在堆上。
-   **slice 的背后数组被重新分配了，因为 append 时可能会超出其容量( cap )。** slice 初始化的地方在编译时是可以知道的，它最开始会在栈上分配。如果切片背后的存储要基于运行时的数据进行扩充，就会在堆上分配。
-   **在 interface 类型上调用方法。** 在 interface 类型上调用方法都是动态调度的 —— 方法的真正实现只能在运行时知道。想像一个 io.Reader 类型的变量 r , 调用 r.Read(b) 会使得 r 的值和切片b 的背后存储都逃逸掉，所以会在堆上分配。


### 参考文章：
1. [Go语言设计与实现](https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-stack-management/)
2. [简单聊聊内存逃逸](https://zhuanlan.zhihu.com/p/145468000)