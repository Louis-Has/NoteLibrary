### MySQL数据类型
####  CHAR 和 VARCHAR 比较

|类型|特点|空间上|时间上|适用场景|
|---|---|---|---|---|
|CHAR(M)|固定长度|浪费存储空间|效率高|存储不大，速度要求高|
|VARCHAR(M)|可变长度|节省存储空间|效率低|非CHAR的情况|

情况1：**存储很短的信息**。比如门牌号码101，201……这样很短的信息应该用`char`，因为`varchar`还要占个byte用于存储信息长度，本来打算节约存储的，结果得不偿失。

情况2：**固定长度的**。比如使用`uuid`作为主键，那用`char`应该更合适。因为他固定长度，`varchar`动态根据长度的特性就消失了，而且还要占个长度信息。

情况3：十分频繁改变的`column`。因为`varchar`每次存储都要有额外的计算，得到长度等工作，如果一个非常频繁改变的，那就要有很多的精力用于计算，而这些对于`char`来说是不需要的。

情况4：具体存储引擎中的情况：

- `MyISAM` 数据存储引擎和数据列：MyISAM数据表，最好使用固定长度(CHAR)的数据列代替可变长度(VARCHAR)的数据列。这样使得整个表静态化，从而使`数据检索更快`，用空间换时间。
- `MEMORY` 存储引擎和数据列：MEMORY数据表目前都使用固定长度的数据行存储，因此无论使用CHAR或VARCHAR列都没有关系，两者都是作为CHAR类型处理的。
- `InnoDB`存储引擎，建议使用VARCHAR类型。因为对于InnoDB数据表，内部的行存储格式并没有区分固定长度和可变长度列（所有数据行都使用指向数据列值的头指针），而且**主要影响性能的因素是数据行使用的存储总量**，由于char平均占用的空间多于varchar，所以除了简短并且固定长度的，其他考虑varchar。这样节省空间，对磁盘I/O和数据存储总量比较好。

#### TEXT类型

- 在MySQL中，TEXT用来保存文本类型的字符串，总共包含4种类型，分别为TINYTEXT、TEXT、MEDIUMTEXT 和 LONGTEXT 类型。
- 在向TEXT类型的字段保存和查询数据时，系统自动按照实际长度存储，不需要预先定义长度。这一点和 VARCHAR类型相同。
- 每种TEXT类型保存的数据长度和所占用的存储空间不同，如下：

|文本字符串类型|特点|长度|长度范围|占用的存储空间|
|---|---|---|---|---|
|TINYTEXT|小文本、可变长度|L|0 <= L <= 255|L + 2 个字节|
|TEXT|文本、可变长度|L|0 <= L <= 65535|L + 2 个字节|
|MEDIUMTEXT|中等文本、可变长度|L|0 <= L <= 16777215|L + 3 个字节|
|LONGTEXT|大文本、可变长度|L|0 <= L<= 4294967295（相当于4GB）|L + 4 个字节|

- **由于实际存储的长度不确定，MySQL 不允许 TEXT 类型的字段做主键**。遇到这种情况，你只能采用 CHAR(M)，或者 VARCHAR(M)。

### SELECT语句 - 执行顺序

##### 1. FROM子句
首先，执行FROM子句，指定要查询的表（或表的组合）。
##### 2. WHERE子句
如果有WHERE子句，查询会根据WHERE条件对FROM子句中的表进行筛选，只选择满足条件的行。
##### 3. GROUP BY

如果有GROUP BY子句，查询会按照指定的列进行分组，将数据分成多个组。

```sql
SELECT cash,count(id) sum FROM author_mes GROUP BY cash  
```

###### ONLY_FULL_GROUP_BY

不赞成sql_mode去掉ONLY_FULL_GROUP_BY
1. MySQL5.7 官方的默认值
2. SQL SERVER、ORACLE、Postgres 规范是一致的，遵循sql-92标准。自带 ONLY_FULL_GROUP_BY 约束，认为违反这个规则的SQL都是不合法的。
3. 可能会有数据不一致的问题 important！

###### HAVING
HAVING 子句用于在 GROUP BY 子句之后对分组后的结果进行筛选。它允许使用聚合函数和条件来过滤分组后的数据。

```sql
SELECT cash,count(id) sum FROM author_mes GROUP BY cash  HAVING cash >100
```


##### 6. SELECT子句
在前面的步骤筛选和分组后，执行SELECT子句，选择要查询的列或表达式，并计算任何聚合函数。
##### 7. 子查询（Subquery）

##### 8. 联合查询（JOIN）

```sql
SELECT Customers.CustomerName, Orders.OrderID
FROM Customers
INNER JOIN Orders ON Customers.CustomerID = Orders.CustomerID;
```

##### 9. ORDER BY子句

使用 ORDER BY 子句可以对查询结果进行排序。ORDER BY 子句通常放在 SELECT 语句的末尾，用于按照指定的列进行升序（ASC）或降序（DESC）排序。
```sql
SELECT id,author,cash FROM author_mes ORDER BY cash ,id DESC
```

##### 10. LIMIT
LIMIT 子句用于限制查询结果返回的行数。它可以帮助你控制查询的结果集大小。

```sql
select _column,_column from _table [where Clause] [limit N][offset M]
```

##### 11. LIKE
LIKE 是一个用于模糊匹配的运算符，通常用于在字符串列中搜索符合特定模式的值。它可以与通配符一起使用，来进行模式匹配的操作。

1. `%`：表示零个或多个字符的任意序列。 例如，使用 `%` 通配符匹配以 "a" 开头的任意字符串：
    
```sql
SELECT *
FROM table_name
WHERE column_name LIKE 'a%';
```
    
2. `_`：表示一个单个字符。 例如，使用 `_` 通配符匹配以 "ab" 开头的两个字符的字符串：
    
```sql
SELECT *
FROM table_name
WHERE column_name LIKE 'ab_';
```
    
3. `[charlist]` 或 `[^charlist]`：表示一个字符集合或不在字符集合中的字符。 例如，使用 `[charlist]` 通配符匹配以 "a" 或 "b" 开头的字符串：
    
```sql
SELECT *
FROM table_name
WHERE column_name LIKE '[ab]%';
```
    
4. `ESCAPE`：用于指定转义字符，用于匹配特殊字符。 例如，使用 `ESCAPE` 关键字指定转义字符为 ""，来匹配以 "%" 字符开头的字符串：
    
```sql
SELECT *
FROM table_name
WHERE column_name LIKE '\% %' ESCAPE '\';
```
    

需要注意的是，LIKE 运算符是大小写敏感的，所以要注意在模式匹配时的大小写问题。

### MySQL 内置函数

1. 字符串函数：
    - **CONCAT**：用于将多个字符串连接在一起。
    - LENGTH：返回字符串的长度。
    - SUBSTRING：提取子字符串。
    - **UPPER** 和 **LOWER**：将字符串转换为大写或小写。

2. 数值函数：
    - **ABS**：返回一个数的绝对值。
    - **ROUND** 和 TRUNCATE：用于数值的四舍五入或截断。
    - **MIN** 和 **MAX**：返回一组数中的最小或最大值。
    - **AVG** 和 **SUM**：计算一组数的平均值和总和。

3. 日期和时间函数：
    - **NOW** 和 CURRENT_TIMESTAMP：返回当前日期和时间。
    - **DATE** 和 **TIME**：提取日期或时间部分。
    - DATE_FORMAT：格式化日期和时间。

4. 条件函数：
    - **IF** 和 CASE：用于条件判断和分支控制。
    - COALESCE：返回第一个非空表达式。

5. 聚合函数：
    - **COUNT**：计算满足条件的行数。
    - GROUP_CONCAT：将分组结果中的值连接为一个字符串。
    - SUM、AVG、MIN、MAX：用于对分组数据进行聚合计算。

6. 数据类型转换函数：
    - CAST 和 CONVERT：用于数据类型的转换。
    - STR_TO_DATE 和 DATE_FORMAT：用于日期和时间格式的转换。

### 索引

通常在设计数据库时，我们会在创建表的时候根据查询需求预先定义索引。索引的目的是加快数据的检索速度，特别是在大型数据库中，使用索引可以显著提高查询性能。

#### 聚簇索引

在 MySQL 的 InnoDB 引擎中，每个索引都会对应一颗 B+ 树，而聚簇索引和非聚簇索引最大的区别在于叶子节点存储的数据不同，聚簇索引叶子节点存储的是行数据，因此通过聚簇索引可以直接找到真正的行数据；而非聚簇索引叶子节点存储的是主键信息，所以使用非聚簇索引还需要回表查询，因此我们可以得出聚簇索引和非聚簇索引的区别主要有以下几个：

- 聚簇索引叶子节点存储的是行数据；而非聚簇索引叶子节点存储的是聚簇索引（通常是主键 ID）。
- 聚簇索引查询效率更高，而非聚簇索引需要进行回表查询，因此性能不如聚簇索引。
- 聚簇索引一般为主键索引，而主键一个表中只能有一个，因此聚簇索引一个表中也只能有一个，而非聚簇索引则没有数量上的限制。

#### 索引类型：
1. 主键索引（**Primary Key Index**）：用于唯一标识表中的每一行，自动创建的索引。
2. 唯一索引（**Unique Index**）：确保索引列的值是唯一的。
3. 普通索引（**Non-Unique Index**）：用于加快查询速度，但允许索引列中的重复值。
4. 全文索引（**Full-Text Index**）：用于全文搜索，适用于对文本内容进行搜索的场景。
5. 空间索引：空间索引用于支持对地理空间数据进行搜索和计算，如点、线、面等。

#### 索引创建情况：
1. 初次创建表：当创建新表时，根据查询的字段以及常用的查询条件，可以为相关列添加索引，以优化常见查询的性能。
2. 频繁查询字段：对于经常用于检索数据的字段，如主键、外键、经常用于 WHERE 子句或 JOIN 的字段，可以考虑为其添加索引。
3. ORDER BY 和 GROUP BY：当经常用到 ORDER BY 或 GROUP BY 子句时，可以为这些字段添加索引，提高排序和分组操作的效率。
4. 大表优化：对于大表的查询，索引可以显著提升检索速度，因此在大表上的关键字段应该添加索引。

#### 索引建立规则

1. 选择**合适的字段**：选择那些经常用于查询条件、连接条件和排序操作的字段来创建索引。通常，主键和外键字段是天然的候选索引字段，其他常用的查询字段也适合创建索引。
    
2. 选择**高基数字段**：**索引字段的基数是指字段中不同值的数量**。高基数字段可以提供更好的过滤能力，因此在建立索引时应优先考虑选择高基数字段。
    
3. 避免过多索引：不要在每个字段上都创建索引，**过多的索引会增加数据维护的成本，同时也会增加写操作的开销**。只创建必要的索引，避免不必要的冗余索引。
    
4. **组合索引**：对于经常一起查询的字段，可以将它们组合在一个索引中，形成组合索引。组合索引可以减少索引数量，提高索引的覆盖度，从而提高查询性能。
    
5. 考虑**查询顺序**：索引字段的顺序也很重要。对于联合索引，要考虑查询时的字段顺序，将经常用于过滤条件的字段放在前面，以提高索引的效率。
    
6. 不要滥用前缀索引：前缀索引是指对字段的前几个字符进行索引，可以节省存储空间。但是过多地使用前缀索引可能会导致索引选择不当，影响查询性能。
    
7. 适当使用索引覆盖：索引覆盖是指查询只需要通过索引就能得到结果，不需要再回表查询数据行。适当使用索引覆盖可以减少数据库的IO操作，提高查询性能。
    
8. 定期维护索引：随着数据的插入、更新和删除，索引会产生碎片，影响查询性能。定期进行索引维护，例如重建索引或优化表，可以保持索引的高效性。
    

总的来说，索引的设计和建立需要综合考虑数据库的查询需求、数据量和硬件资源等因素。通过合理地设计和使用索引，可以显著提高数据库的查询性能和并发能力。但是过多或不必要的索引也会增加数据库的维护成本和写入性能，因此需要权衡好索引的数量和适用场景。

#### 索引优化
	1.  场景 order by ，join on
	2.  unique ，index
	3.  not null
	4.  联合索引

#### 索引下推

- 索引下推（index condition pushdown ）简称 ICP，在 Mysql5.6 的版本上推出，用于优化查询。**可以将部分过滤条件下推到存储引擎层，以减少从存储引擎到服务器的数据传输**，从而提高查询性能。通常，MySQL在服务器层检索数据并应用过滤条件，然后再将结果返回给客户端。但是，索引下推可以在存储引擎层级别更早地过滤数据。

- 在不使用 ICP 的情况下，在使用**非主键索引（又叫普通索引或者二级索引）** 进行查询时，存储引擎通过索引检索到数据，然后返回给 MySQL 服务器，服务器然后判断数据是否符合条件 。

- 在使用 ICP 的情况下，如果存在某些被索引的列的判断条件时，MySQL 服务器将这一部分判断条件传递给存储引擎，然后由存储引擎通过判断索引是否符合 MySQL 服务器传递的条件，只有当索引符合条件时才会将数据检索出来返回给 MySQL 服务器 。

- **索引条件下推优化可以减少存储引擎查询基础表的次数，也可以减少 MySQL 服务器从存储引擎接收数据的次数。**

```mysql
SELECT * from user where name like ‘陈 %’ and age=20
```

#### 索引失效情况

1. **使用函数、运算符或表达式**：当在查询中对索引列使用函数、运算符或表达式时，索引可能会失效。例如，`WHERE YEAR(timestamp_column) = 2023` 将会导致索引失效，因为函数会对索引列进行计算，使得无法直接利用索引进行检索。
    
2. **在索引列上使用 NOT、<> 或 IS NULL**：当在索引列上使用 `NOT`、`<>` 或 `IS NULL` 条件时，索引可能会失效。这是因为索引通常是按照升序或降序存储的，而这些条件可能导致 MySQL 不使用索引进行检索。
    
3. **模糊查询开头使用通配符**：在模糊查询中，如果通配符（例如 `%`）出现在查询的开头，索引可能会失效。例如，`WHERE name LIKE '%John'` 将会导致索引失效。
    
4. **联合索引中未使用第一个列**：在联合索引中，如果没有使用第一个列，而是从索引的中间列开始进行检索，索引可能会失效。
    
5. **查询返回行数过多**：当查询返回的行数较大时，数据库可能会决定放弃使用索引，因为全表扫描可能更为高效。
    
6. **数据分布不均匀**：如果索引列的数据分布极不均匀，例如某个值在数据中出现的频率非常高，索引可能会失效，因为数据库可能会选择全表扫描来查找数据。
    
7. **隐式类型转换**：如果在查询中进行了隐式类型转换，例如将字符串列与数字进行比较，索引可能会失效。
    
8. **大数据量的排序操作**：如果查询需要对大数据量的结果集进行排序，可能会选择不使用索引。

#### 索引的数据结构：B+树

**1、相同思想和策略**

从平衡二叉树、B树、B+树、B\*树总体来看它们的贯彻的思想是相同的，都是采用二分法和数据平衡策略来提升查找数据的速度；

**2、不同的方式对树的不断优化**

1、首先，为了保证树的节点均匀分布，所以在二叉树的基础上加上了平衡算法，就有了**平衡二叉树**。

2、为了减少树的高度，所以**B树**一个节点下面可以添加N个子节点，然后每个节点的大小限制在磁盘块容量大小，让节点只需要通过一次IO就能读取到所有数据，通过增加节点存储的数据减少了树的高度，而节点的数据变多并没有让IO次数变多。

3、B+树在B树的基础上，在查询的稳定性 和排序方面进行了优化，因为**B+树**所有的数据都会保存到叶子节点，然后所有叶子节点本身是有序的。

4、**B\*树**为了减少树在构建过程中节点的拆分、合并次数，所以在每个节点上都保存了旁边节点的指针，在节点需要进行拆分、合并时，优先从旁边节点挪数据，从而减少构建过程中节点拆分、合并的次数，提升了树的构建性能。

#### mysql为什么用B+树而不用跳表

1. **磁盘存储效率**：B+树在磁盘上的存储结构更加紧凑，具有更好的局部性，这意味着在读取数据时，磁盘上的数据块更有可能一次性加载到内存中，减少了磁盘 I/O 操作。而跳表的数据结构相对分散，可能需要更多的磁盘 I/O 操作，性能相对较差。
    
2. **稳定的查询性能**：B+树的查询性能在大多数情况下是稳定的，而跳表的查询性能会受到数据分布的影响。在某些情况下，跳表的查询性能可能不如 B+树。
    
3. **支持范围查询**：B+树天生支持范围查询，这在数据库中非常常见。跳表虽然可以执行范围查询，但需要额外的逻辑处理。
    
4. **事务性数据库的需求**：B+树是关系数据库管理系统（RDBMS）的标准索引数据结构，它支持事务性数据库的需求，例如支持 ACID 事务、并发控制等。跳表在这方面的支持可能需要额外的工作。
    
5. **成熟性**：B+树是数据库领域的经典数据结构，有着长时间的验证和优化历史。跳表在数据库中的应用相对较少，因此相对来说不太成熟。

### 分库分表规则

分库分表是指将大型数据库拆分为多个小型数据库（分库）以及将大表拆分为多个小表（分表），以**实现数据库的水平扩展和提高数据库性能**。在进行分库分表时，需要考虑一些规则和注意事项，以保证数据一致性和查询性能。

1. 垂直拆分与水平拆分：在分库分表前，首先需要根据业务需求确定是采用垂直拆分还是水平拆分。**垂直拆分是指将不同业务功能的数据放在不同的库中**，如将用户信息、订单信息分开存储。**水平拆分是指将一个大表的数据拆分成多个小表**，如按照时间范围或按照某个字段进行拆分。
    
2. 数据划分规则：确定数据划分规则是分库分表的关键。在**进行水平拆分时，可以根据业务数据的特点选择合适的划分规则**，如按照日期范围、地理位置、用户ID 等划分。确保数据在拆分后能够均匀分布，避免热点数据的问题。
    
3. 一致性和跨库事务：分库分表后，可能需要处理分布在不同库中的数据一致性问题。对于涉及跨库的事务操作，需要考虑**使用分布式事务或两阶段提交等机制**来保证数据的一致性。
    
4. 分库分表工具：有一些开源的分库分表工具可供使用，如ShardingSphere、Vitess等。这些工具可以简化分库分表的实现过程，并提供一些额外的功能，如读写分离、负载均衡等。
    
5. 迁移和扩容：在分库分表后，可能需要进行数据迁移或扩容的操作。迁移数据时需要保证数据的完整性和一致性，同时需要考虑数据库的备份和恢复策略。
    
6. 优化查询：分库分表可能会增加查询的复杂性。在编写查询语句时，需要考虑如何优化查询性能，避免跨库查询和全表扫描的情况。
    

总的来说，分库分表是一种常用的数据库架构优化手段，可以有效提高数据库的性能和扩展性。但分库分表也会增加系统复杂性，需要在设计和实现过程中综合考虑数据一致性、查询性能和可扩展性等方面的问题。

### 存储引擎

MyISAM 和 InnoDB 是 MySQL 中两种常用的存储引擎（Storage Engine），用于管理数据的存储和访问。它们有不同的特点和适用场景。

1. MyISAM： MyISAM 是 MySQL 的默认存储引擎（在 MySQL 5.5.5 版本之前）。它以较简单的方式存储数据，对于读操作具有较好的性能，适用于大量的读操作和少量的写操作的场景。
    
    主要特点：
    
    - 不支持事务：MyISAM 不支持事务，这意味着它不支持事务的原子性、一致性、隔离性和持久性（ACID 特性）。
    - **表级锁**：MyISAM 使用表级锁，这意味着在执行写操作时会锁定整个表，可能导致并发写操作的性能瓶颈。
    - **全文索引**：MyISAM 支持全文索引，适用于全文搜索的场景。
    
    由于 MyISAM 不支持事务和使用表级锁，不建议在高并发、写操作频繁的业务场景中使用 MyISAM 引擎。
    
2. InnoDB： InnoDB 是 MySQL 中另一种常用的存储引擎。它支持事务和行级锁，提供了更好的数据完整性和并发性，适用于高并发和频繁写入的业务场景。
    
    主要特点：
    
    - **支持事务**：InnoDB 支持事务，允许用户实现事务的原子性、一致性、隔离性和持久性（ACID 特性）。
    - **行级锁**：InnoDB 使用行级锁，可以在并发读写操作时避免表级锁带来的性能瓶颈，提高了并发性能。
    - 外键支持：InnoDB 支持外键约束，可以保证数据的完整性。
    
    InnoDB 是 MySQL 5.5.5 版本及以后的默认存储引擎。对于大多数应用来说，InnoDB 引擎通常是更好的选择，特别是对于需要支持事务和并发写入的应用场景。
    

在选择存储引擎时，应根据应用的需求和特点来选择合适的引擎。对于读多写少的简单查询场景，MyISAM 可能会有更好的性能。而对于需要事务支持和高并发写入的应用，InnoDB 是更稳定和可靠的选择。

### 事务（Transaction）
1.  begin;
2.  commit;
3.  rollback;

当面试中涉及 MySQL 事务的问题时，通常会涵盖数据库事务的基本概念、事务的特性（ACID）、并发控制和隔离级别等方面。以下是一些可能出现在 MySQL 事务相关面试题中的问题：

1. 什么是数据库事务？ 回答：数据库事务是一组被视为单个逻辑单元的数据库操作，要么全部成功执行（提交），要么全部回滚（撤销），从而**确保数据的一致性和完整性**。
    
#### 2. 事务的 ACID 特性是什么？
	1. 原子性（Atomicity）：事务是一个原子操作，要么全部执行成功，要么全部失败回滚，不存在部分执行的情况。如果事务中的任何一个操作失败，整个事务将被回滚，数据库状态回到事务开始前的状态。
	2. 一致性（Consistency）：事务执行前后，数据库的数据应该保持一致性。这意味着在事务执行过程中，数据库从一个合法状态转换到另一个合法状态，不会破坏数据的完整性和约束条件。
	3. 隔离性（Isolation）：多个事务可以并发地同时访问数据库，但每个事务的操作对其他事务应该是隔离的，一个事务的操作不应该影响其他事务的执行结果。隔离性通过事务的隔离级别来控制，不同的隔离级别提供了不同的并发控制机制。
	4. 持久性（Durability）：一旦事务提交成功，对数据库的修改就是永久性的，即使在系统崩溃后也不会丢失。
	
#### 3. 事务的 ACID 特性实现机制：REDO LOG  UNDO LOG
	1. **隔离性：通过锁机制实现**
	2. **原子性、一致性、持久性由事务的`redo`日志和`undo`日志来保证**
	    1. `REDO LOG`称为重做日志，提供再写入操作，恢复提交事务修改的页操作（如果事务写入到一半，服务器宕机，重启之后，能够保证事务写入完整，保证数据的可靠性），用来保证事务的持久性。
	    2. `UNDO LOG`称为回滚日志，回滚行记录到某个特定版本，用来保证事务的原子性、一致性。

`REDO`和`UNDO`都可以视为一种恢复操作，但是：

- `redo log`：存储引擎`InnoDB`生成的日志，记录的是物理级别上的页的修改操作，比如`页号xxx`、`偏移量yyy`写入了`数据zzz`。主要是为了保证数据的可靠性。
    
- `undo log`：存储引擎`InnoDB`生成的日志，记录的是**逻辑操作**日志，比如对某一行数据进行了`INSERT`语句的操作，那么`undo log`就记录一条与之相反的`DELETE`操作。主要用于**事务的回滚**（`undo log`记录的是每个修改操作的**逆操作**）和一**致性非锁定读**（`undo log`回滚行记录到某种特定的版本–`MVCC`，即多版本并发控制）。
    
5. MySQL 默认使用的事务隔离级别是什么？ 回答：MySQL 默认使用的事务隔离级别是 **REPEATABLE READ**。这是为了保证事务的可重复读性，即在同一个事务中多次读取同一数据，得到的结果都是一样的。
    
4. 什么是脏读（Dirty Read）、幻读（Phantom Read）和不可重复读（Non-repeatable Read）？ 回答：这些都是并发事务执行时可能出现的问题。
    
    - **脏读**是指一个事务读取了另一个事务未提交的数据。
    - **幻读**是指一个事务读取了另一个事务已提交的新增数据，导致之前的查询结果和之后的查询结果不一致。
	    - 使用 SERIALIZABLE 隔离级别：
			`SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;`
	    - 使用锁定读（FOR UPDATE）：
			`SELECT * FROM table_name WHERE column_name = 'value' FOR UPDATE;`
    - **不可重复读**是指一个事务内两次读取同一数据，但两次读取的结果不一致，可能是因为另一个并发事务修改了数据。
5. 如何解决并发事务的问题？ 回答：可以通过设置不同的事务隔离级别来解决并发事务的问题。MySQL 支持四种事务隔离级别：READ UNCOMMITTED、READ COMMITTED、REPEATABLE READ 和 SERIALIZABLE。每个隔离级别都有不同的特点和用途，可以根据实际场景选择合适的隔离级别。

#### 事务隔离级别

在 MySQL 中，可以通过设置合适的事务隔离级别来解决脏读问题。事务隔离级别包括 READ UNCOMMITTED、READ COMMITTED、REPEATABLE READ 和 SERIALIZABLE。设置事务隔离级别为 READ COMMITTED 或更高级别，可以避免脏读的问题。

1. **READ UNCOMMITTED（读未提交）**：最低的隔离级别，事务可以读取未提交的数据。这种隔离级别可能会出现脏读、不可重复读和幻读问题。
2. **READ COMMITTED（读已提交）**：事务**只能读取已提交的数据，禁止脏读**。但仍可能出现不可重复读和幻读问题。
3. **REPEATABLE READ（可重复读）默认使用**：事务**开始时建立一个快照，保证在事务执行过程中可以多次读取同样的数据**，并阻止不可重复读。但仍可能出现幻读问题。
4. **SERIALIZABLE（串行化）**：最高的隔离级别，事务按顺序执行，避免了脏读、不可重复读和幻读问题。但并发性较差，可能导致性能问题。

设置事务隔离级别的方式为：

```sql
SET TRANSACTION ISOLATION LEVEL <isolation_level>;
```


### MVCC 多版本并发控制

MVCC时**通过数据行的多个版本管理来实现数据库的并发控制**。换言之，就是为了查询一些正在被另一个事务更新的行，并且可以看到它们`被更新之前的值`，这样在做查询的时候就不用等待另一个事务释放锁。

#### 快照读与当前读

MVCC在MySQL InnoDB中的实现主要是为了提高数据库并发性能，用更好的方式去处理 `读-写` 冲突，做到即使有读写冲突时，也能做到不`加锁`，`非阻塞并发读`，这个读就是**快照读**。`当前读实际上是一种加锁的控制，是悲观锁的实现`，`MVCC的本质是基于采用乐观锁思想的一种方式`。

#### MVCC整体操作流程

1. 首先获取事务ID
2. 获取`ReadView`
3. 查询得到的数据，然后与`ReadView`中的事务版本号进行对比；
4. 如果不符合`ReadView`规则，就需要从 `undo log`中获取历史快照
5. 最后返回符合规则的数据

`MVCC`在`READ COMMITTED`和`REPEATABLE READ`隔离级别这两种隔离级别的事务，在执行读快照操作时访问版本链，这样使不同事务的`读-写`、`写-读`操作并发执行，从而提高性能。

`MVCC`在`READ COMMITTED`和`REPEATABLE READ`隔离级别生成`ReadView`的时机不同：

- `READ COMMITTED`每次读取时都生成`ReadView`
- `REPEATABLE READ`在第一次读取时生成`ReadView`，以后复用
### 锁机制

MySQL 的锁机制是**用于实现并发控制的重要组成部分**，确保在多个事务同时访问数据库时数据的一致性和完整性。MySQL 支持多种类型的锁，这些锁可以在事务执行过程中对数据进行加锁和解锁，以控制数据的访问权限。

#### 并发问题解决方案 MVCC

在 MySQL 的 InnoDB 存储引擎中，MVCC（Multi-Version Concurrency Control）是默认的并发控制方式，用于**解决并发冲突的无锁并发控制**。

- 方案一：读操作利用多版本并发控制（`MVCC`），写操作进行加锁
    
    `MVCC`，生成一个`ReadView`，通过`ReadView`找到符合条件的记录版本（历史版本由`undo`日志构建），查询语句只能读到在生成`ReadView`之前已提交事务所做的更改，生成`ReadView`之前为提交的事务或者之后才开启的新事务所做的更改是看不到的。而写操作肯定针对的是最新版本的记录，读记录的历史版本和改动记录的最新版本本身并不冲突，也就是采用`MVCC`时，**读-写操作**并不冲突。
    
    > 普通的`SELECT`语句在`READ COMMITED`和`REPEATABLE READ`隔离级别下会使用到`MVCC`读取记录。
    > 
    > - 在`READ COMMITED`隔离级别下，一个事务在执行过程中每次执行`SELECT`操作时都会生成一个`ReadView`，`ReadView`的存在保证了事务不可读取到未提交的事务所做的更改，避免了脏读现象；
    > - 在`REPEATABLE READ`隔离级别下，一个事务在执行过程中只有第一次执行`SELECT`操作才会生成一个`ReadView`，之后的`SELECT`操作都复用这个`ReadView`，避免了不可重复读和幻读的问题；
    
- 方案二：读写都加锁
    
    有些业务不允许读取到记录的旧版本，此时就需要加锁。这种情况下，脏读、不可重复读、幻读（幻读加锁会比较麻烦，主要是无法确定新的记录如何加锁）的问题就全部都解决了，事务没有提交时，无法读取或者修改数据。
    

汇总：

- 采用`MVCC`的话，读-写操作并不冲突，性能更高。
    
- 采用加锁方式的话，读-写操作彼此需要排队，影响性能。
    

一般情况下采用`MVCC`，业务特殊情况下，采用加锁的方式。

#### 从数据操作的类型划分：读写锁

1. **共享锁（Shared Lock，也称为读锁、S锁）**：
    - 允许多个事务同时持有共享锁，并且可以共享同一份数据。
    - 共享锁用于防止其他事务对数据进行修改，但允许其他事务读取数据。
    - 适用于并发读取的场景。

    ```mysql
SELECT ... FOR SHARE;
    ```

1. **排他锁（Exclusive Lock，也称为写锁、E锁）**：
    - 一次只能有一个事务持有排他锁。
    - 排他锁用于防止其他事务对数据进行读取和修改，保证只有一个事务能够修改数据。
    - 适用于并发写入的场景。

```mysql
SELECT ... FOR UPDATE;
```

#### 从数据操作的粒度划分：表级锁、页级锁、行锁

1. 表级锁（Table-level Lock）：
    - 表级锁是最粗粒度的锁，对整个表进行加锁。
    - 使用 LOCK TABLES 语句可以对表进行加锁，防止其他事务对整个表进行读写操作。
    - 一般情况下，表级锁的并发性较差，会导致性能瓶颈。
2. **行级锁、记录锁（Row-level Lock）**：
    - 行级锁是最细粒度的锁，对数据库中的每一行数据进行加锁。
    - InnoDB 存储引擎支持行级锁，通过在事务中使用 **SELECT ... FOR UPDATE** 或 SELECT ... LOCK IN SHARE MODE 可以对查询的行进行加锁。
    - 行级锁的并发性较好，可以减少锁的竞争，提高数据库的并发性能。
3. 页级锁（Page-level Lock）：
    - 页级锁对数据库中的每一页数据进行加锁。
    - 在某些存储引擎中可能会使用页级锁作为粒度介于表级锁和行级锁之间的锁。
4. **间隙锁（Gap Locking）**： 
    间隙锁用于保护范围查询，防止其他事务在查询范围内插入新的数据，避免幻读问题。间隙锁在 InnoDB 存储引擎中实现。

使用合适的锁机制可以确保并发事务之间的数据访问是正确、安全和有效的。在实际开发中，需要根据业务需求和数据库引擎的特性选择适合的锁策略，以保证数据库的性能和数据完整性。

#### 解决幻读问题：临时键锁 和 间隙锁

在 MySQL 中，临时键锁（Temporary Key Lock）和间隙锁（Gap Lock）都是 InnoDB 存储引擎内部用于支持不同事务隔离级别的一种锁机制。它们的作用是确保多个事务并发执行时，保持数据的一致性和避免并发问题，特别是针对范围查询的情况。

1. **临时键锁（Temporary Key Lock）**：
    - 临时键锁是 InnoDB 存储引擎在执行特定类型的 SQL 查询时自动生成的锁。它主要用于支持不同的事务隔离级别，特别是在 REPEATABLE READ 和 SERIALIZABLE 隔离级别下，用于避免幻读问题。
    - **当执行 WHERE 子句带有范围条件的 SELECT 查询时**，InnoDB 会为查询的范围键值创建临时键锁，保护这个范围内的键值不会被其他事务插入。
    - 临时键锁是 InnoDB 存储引擎内部的一种锁，它并不是由用户显式创建的，也无法直接查看。
2. **间隙锁（Gap Lock）**：
    - 间隙锁是 InnoDB 存储引擎用于锁定范围查询的一种锁机制。它主要用于在**事务执行范围查询时，锁定查询范围内的间隙，防止其他事务在这个间隙内插入新的数据**。
    - 间隙锁的作用是避免幻读问题，即当一个事务在查询某一范围的数据时，另一个事务在这个范围内插入了新的数据，导致前一个事务再次查询时出现新插入的数据。
    - 间隙锁是 InnoDB 存储引擎的一种锁，它是基于范围的锁定，用于保护范围查询的数据完整性。

需要注意的是，临时键锁和间隙锁是 InnoDB 存储引擎内部的锁机制，在执行特定类型的查询时自动生成和管理，用户无法直接控制或查看这些锁。它们的目的是为了支持不同事务隔离级别下的数据一致性和并发控制。

#### 锁算法的动态产生和退化

在 MySQL 中，锁算法的动态产生和退化是指**在并发事务处理过程中，根据事务隔离级别和具体的查询操作，MySQL 存储引擎会智能地选择合适的锁类型，并根据锁冲突的情况进行动态调整，以保持数据的一致性和并发性能。** 下面更详细地说明锁算法的动态产生和退化过程：

1. 动态产生锁：
    - 记录锁（Record Lock）的产生：当一个事务对数据库表中的某一行数据进行修改或锁定时，MySQL 会生成记录锁，**确保其他事务无法同时修改或锁定该行**，从而保持数据的一致性。记录锁适用于对行级别的并发控制。
    - 间隙锁（Gap Lock）的产生：间隙锁用于保护范围查询，**防止其他事务在查询范围内插入新的数据**。在执行带有范围条件的查询时，MySQL 可能会生成间隙锁，锁定查询范围内的间隙。间隙锁适用于对范围的并发控制。
2. 动态退化锁：
    - **间隙锁退化为表级锁**：当间隙锁无法满足查询条件时，可能会退化为表级锁。例如，在某些情况下，数据库可能需要锁定整个表来确保数据的一致性，这时间隙锁可能会退化为表级锁。
    - **记录锁退化为间隙锁**：在事务隔离级别为 `REPEATABLE READ` 或 `SERIALIZABLE` 时，MySQL 可能会将记录锁退化为间隙锁。例如，在执行带有范围条件的查询时，为了防止幻读，记录锁可能会退化为间隙锁来保护整个范围。
3. 锁冲突的处理：
    - 锁冲突是指多个事务之间由于需要对相同的数据资源加锁而产生的竞争。当多个事务同时请求对同一数据资源进行修改或锁定时，可能会发生锁冲突。MySQL 存储引擎会检测锁冲突，并根据锁冲突的情况来调整锁的产生和退化，以避免死锁的发生，保持数据的一致性。

总的来说，MySQL 的锁算法在执行查询操作时会根据事务隔离级别和锁冲突的情况智能地选择合适的锁类型，并在必要时进行锁的退化，以保证数据库的一致性和并发性能。这些调整是数据库存储引擎内部根据具体情况进行管理的，用户无需显式干预。在设计数据库结构和编写查询语句时，应该了解锁算法的特性，避免并发问题，并根据业务需求选择合适的事务隔离级别和锁粒度。

#### 从对待锁的态度划分：乐观锁、悲观锁

1. 乐观锁
	1. **添加版本字段**： 在你的数据表中，可以添加一个版本字段（也称为时间戳字段或版本号字段），用于记录数据的版本信息。每次更新数据时，都会同时更新版本字段的值。
	2. **读取数据并比较版本**： 当要更新数据时，首先读取数据并获取当前的版本信息。然后，在更新之前，再次检查版本信息是否与之前读取的版本匹配。如果版本不匹配，说明在你读取数据后有其他操作更新了数据，你可以选择放弃或重试更新。
	3. 注意：如果数据表时**读写分离**的表，当`master`表中写入的数据没有及时同步到`slave`表中时，会造成更新一致失效的问题。此时需要`强制读取master表`中的数据。（将`select`语句放到事务中即可，这时候查询的就是`master`主库）
2. 悲观锁
	1. 核心思想是在进行数据操作之前，预先获取锁，以防止其他事务对同一数据进行并发修改。
	2. **行锁**是一种常用的悲观锁实现方式。

#### 死锁（Deadlock）

死锁是在并发环境中发生的一种特殊情况，它指的是**两个或多个事务相互持有对方所需要的资源，从而导致所有事务都无法继续执行，被永久地阻塞在等待对方释放资源的状态**。简单来说，死锁是由于资源竞争导致的一种僵局，使得系统无法继续进行。

死锁的解决方案
1. 等待，直到超时（`innodb_lock_wait_timeout=50s`），超时之后，自动回滚，另外一个事务继续运行。
2. 使用死锁检测进行死锁处理，通过`wait-for graph算法`来主动进行死锁检测，每当锁请求无法立即满足需要并进入等待时，`wait-for graph算法`都会被触发。


### slow_query_log

`slow_query_log` 是 MySQL 数据库的一个参数，用于开启或关闭慢查询日志记录功能。慢查询日志记录了执行时间超过一定阈值的 SQL 查询语句，帮助开发人员或数据库管理员识别数据库中执行时间较长的查询，从而优化和改进数据库性能。

```sql
SHOW VARIABLES LIKE 'slow_query_log';
```

### processlist

在 MySQL 中，`SHOW PROCESSLIST` 是一个用于查看当前连接到数据库服务器的客户端进程（线程）列表的命令。它可以用于监视数据库中正在执行的查询和操作，了解当前数据库的运行情况和性能状况。

```sql
SHOW PROCESSLIST;
```


### SQL优化
 1. 尽量避免使用 NULL
 2. show processlist
 3. 读写分离
 4. in > between
 5. in > exists
 6. or > union 组合查询
 7. where 1=1 > 去掉
 8. where 联合索引 按顺序
 9. 避免隐式类型转换
 10. join 小表在前
 11. 用表 的 别名
 12. HAVING > where
 13. where 从左到右的顺序
 14. inset 多条合并插入
 15. order by null
 16. union > union all
 17. delete > truncate

### MySQL  场景题目

1. **数据库设计**：
    - 你需要为一个电子商务网站设计数据库模型，包括商品、订单和用户信息。如何设计这个数据库模型？
2. **查询优化**：
    - 有一个订单表，包含数百万条数据，你如何优化查询以获取最近一周内的订单数据？
3. **索引优化**：
    - 什么是索引覆盖查询？你如何利用索引覆盖查询来提高查询性能？
4. **高可用性**：
    - 你如何设置 MySQL 数据库的主从复制来实现读写分离和故障恢复？
5. **事务处理**：
    - 在一个电影订票系统中，如何确保当用户购买电影票时，座位信息不会被多次分配？
6. **并发控制**：
    - 你如何处理在高并发情况下的数据一致性问题？考虑使用锁机制、MVCC 或其他技术。
7. **备份和恢复**：
    - 描述一下你的数据库备份和恢复策略，如何保证数据的完整性和可恢复性？
8. **触发器和视图**：
    - 你如何使用触发器来实现在订单插入时自动更新客户订单计数？又如何创建一个视图来显示某个部门的员工信息？
9. **数据库扩展**：
    - 当你的数据库面临数据增长时，你会采取哪些方法来扩展数据库的性能和存储容量？
10. **安全性和防御**：
    - 如何防止 SQL 注入攻击？你如何为数据库设置合适的权限和访问控制？
11. **性能监控和优化**：
    - 在生产环境中，如何监控数据库性能，并根据监控结果进行性能优化？


1. **电子商务平台**： 问题：如何设计数据库以支持电子商务平台，包括商品、订单、用户等信息？ 答案：设计商品表、订单表、用户表等，并建立适当的关联关系。使用索引来提高查询性能，实现购物车功能，确保事务的一致性和隔离性。
    
2. **社交媒体应用**： 问题：如何设计数据库以支持社交媒体应用，包括用户关系、帖子、评论等功能？ 答案：设计用户表、帖子表、评论表等，使用 JOIN 操作来检索相关用户的帖子和评论。使用触发器和存储过程实现通知功能。
    
3. **日志和审计跟踪**： 问题：如何在数据库中实现日志和审计跟踪，以便记录用户活动和操作历史？ 答案：创建日志表，记录用户的登录、查询和修改操作。使用触发器或应用程序层来插入日志记录，确保数据的安全性和完整性。
    
4. **数据分析**： 问题：如何使用 MySQL 进行数据分析，例如统计、报表等？ 答案：使用聚合函数（SUM、AVG、COUNT 等）进行统计，编写复杂查询来生成报表。考虑性能，可能需要使用索引或者冗余存储汇总数据。
    
5. **读写分离**： 问题：如何实现 MySQL 数据库的读写分离，提高并发性能？ 答案：配置主数据库和多个从数据库，将写操作发送到主数据库，而读操作分发到从数据库。使用负载均衡来分配读请求。
    
6. **数据库备份和恢复**： 问题：如何定期备份数据库，以及在数据库崩溃时如何恢复数据？ 答案：使用 mysqldump 命令进行备份，定期保存备份文件。在崩溃时，使用备份文件和恢复工具将数据还原。
    
7. **多租户应用**： 问题：如何设计支持多租户应用，使不同租户的数据彼此隔离？ 答案：为每个租户创建独立的数据库或表，确保数据隔离。使用视图或存储过程来简化跨租户的查询操作。
    
8. **缓存与数据库**： 问题：如何使用缓存来减轻数据库的负载，提高响应速度？ 答案：使用缓存工具如 Redis，将热门数据缓存起来，减少数据库访问次数。定期更新缓存以保持数据一致性。

### 参考文章：
1. [SQL优化](https://developer.aliyun.com/article/779151)
2. [数据结构之MySQL独爱B+树(二叉树、AVL树、红黑树、B树对比)](https://learnku.com/articles/52909)
3. [Golang中的本地锁和分布式锁](https://www.xiaoyeshiyu.com/post/9e4b.html)
4. [MySQL学习笔记事务和锁篇](https://www.xiaoyeshiyu.com/post/fa7d.html)
5. [MySQL MVCC实现原理](https://juejin.cn/post/7212812263098761275#heading-2)
