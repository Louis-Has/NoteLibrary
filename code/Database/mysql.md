### SELECT语句 - 执行顺序

##### 1. FROM子句：首先，执行FROM子句，指定要查询的表（或表的组合）。



##### 2. WHERE子句：如果有WHERE子句，查询会根据WHERE条件对FROM子句中的表进行筛选，只选择满足条件的行。



##### 3. GROUP BY

如果有GROUP BY子句，查询会按照指定的列进行分组，将数据分成多个组。

```sql
SELECT cash,count(id) sum FROM author_mes GROUP BY cash  
```

###### ONLY_FULL_GROUP_BY

不赞成sql_mode去掉ONLY_FULL_GROUP_BY
1. MySQL5.7 官方的默认值
2. SQL SERVER、ORACLE、Postgres 规范是一致的，遵循sql-92标准。自带 ONLY_FULL_GROUP_BY 约束，认为违反这个规则的SQL都是不合法的。
3. 可能会有数据不一致的问题 important！

###### HAVING
HAVING 子句用于在 GROUP BY 子句之后对分组后的结果进行筛选。它允许使用聚合函数和条件来过滤分组后的数据。

```sql
SELECT cash,count(id) sum FROM author_mes GROUP BY cash  HAVING cash >100
```


##### 6. SELECT子句：在前面的步骤筛选和分组后，执行SELECT子句，选择要查询的列或表达式，并计算任何聚合函数。



##### 7. 子查询（Subquery）



##### 8. 联合查询（JOIN）
###### ON


##### 9. ORDER BY子句：如果有ORDER BY子句，查询会按照指定的列对结果进行排序。

使用 ORDER BY 子句可以对查询结果进行排序。ORDER BY 子句通常放在 SELECT 语句的末尾，用于按照指定的列进行升序（ASC）或降序（DESC）排序。
```sql
SELECT id,author,cash FROM author_mes ORDER BY cash ,id DESC
```

##### 10. LIMIT
LIMIT 子句用于限制查询结果返回的行数。它可以帮助你控制查询的结果集大小。

```sql
select _column,_column from _table [where Clause] [limit N][offset M]
```

##### 11. LIKE
LIKE 是一个用于模糊匹配的运算符，通常用于在字符串列中搜索符合特定模式的值。它可以与通配符一起使用，来进行模式匹配的操作。

1. `%`：表示零个或多个字符的任意序列。 例如，使用 `%` 通配符匹配以 "a" 开头的任意字符串：
    
```sql
SELECT *
FROM table_name
WHERE column_name LIKE 'a%';
```
    
2. `_`：表示一个单个字符。 例如，使用 `_` 通配符匹配以 "ab" 开头的两个字符的字符串：
    
```sql
SELECT *
FROM table_name
WHERE column_name LIKE 'ab_';
```
    
3. `[charlist]` 或 `[^charlist]`：表示一个字符集合或不在字符集合中的字符。 例如，使用 `[charlist]` 通配符匹配以 "a" 或 "b" 开头的字符串：
    
```sql
SELECT *
FROM table_name
WHERE column_name LIKE '[ab]%';
```
    
4. `ESCAPE`：用于指定转义字符，用于匹配特殊字符。 例如，使用 `ESCAPE` 关键字指定转义字符为 ""，来匹配以 "%" 字符开头的字符串：
    
```sql
SELECT *
FROM table_name
WHERE column_name LIKE '\% %' ESCAPE '\';
```
    

需要注意的是，LIKE 运算符是大小写敏感的，所以要注意在模式匹配时的大小写问题。


### MySQL 内置函数

1. 字符串函数：
    - **CONCAT**：用于将多个字符串连接在一起。
    - LENGTH：返回字符串的长度。
    - SUBSTRING：提取子字符串。
    - **UPPER** 和 **LOWER**：将字符串转换为大写或小写。

2. 数值函数：
    - **ABS**：返回一个数的绝对值。
    - **ROUND** 和 TRUNCATE：用于数值的四舍五入或截断。
    - **MIN** 和 **MAX**：返回一组数中的最小或最大值。
    - **AVG** 和 **SUM**：计算一组数的平均值和总和。

3. 日期和时间函数：
    - **NOW** 和 CURRENT_TIMESTAMP：返回当前日期和时间。
    - **DATE** 和 **TIME**：提取日期或时间部分。
    - DATE_FORMAT：格式化日期和时间。

4. 条件函数：
    - **IF** 和 CASE：用于条件判断和分支控制。
    - COALESCE：返回第一个非空表达式。

5. 聚合函数：
    - **COUNT**：计算满足条件的行数。
    - GROUP_CONCAT：将分组结果中的值连接为一个字符串。
    - SUM、AVG、MIN、MAX：用于对分组数据进行聚合计算。

6. 数据类型转换函数：
    - CAST 和 CONVERT：用于数据类型的转换。
    - STR_TO_DATE 和 DATE_FORMAT：用于日期和时间格式的转换。

### 索引

通常在设计数据库时，我们会在创建表的时候根据查询需求预先定义索引。索引的目的是加快数据的检索速度，特别是在大型数据库中，使用索引可以显著提高查询性能。

#### 索引类型：
1. 主键索引（**Primary Key Index**）：用于唯一标识表中的每一行，自动创建的索引。
2. 唯一索引（**Unique Index**）：确保索引列的值是唯一的。
3. 普通索引（**Non-Unique Index**）：用于加快查询速度，但允许索引列中的重复值。
4. 全文索引（**Full-Text Index**）：用于全文搜索，适用于对文本内容进行搜索的场景。
5. 空间索引：空间索引用于支持对地理空间数据进行搜索和计算，如点、线、面等。

#### 索引创建情况：
1. 初次创建表：当创建新表时，根据查询的字段以及常用的查询条件，可以为相关列添加索引，以优化常见查询的性能。
2. 频繁查询字段：对于经常用于检索数据的字段，如主键、外键、经常用于 WHERE 子句或 JOIN 的字段，可以考虑为其添加索引。
3. ORDER BY 和 GROUP BY：当经常用到 ORDER BY 或 GROUP BY 子句时，可以为这些字段添加索引，提高排序和分组操作的效率。
4. 大表优化：对于大表的查询，索引可以显著提升检索速度，因此在大表上的关键字段应该添加索引。

#### 索引建立规则

1. 选择**合适的字段**：选择那些经常用于查询条件、连接条件和排序操作的字段来创建索引。通常，主键和外键字段是天然的候选索引字段，其他常用的查询字段也适合创建索引。
    
2. 选择**高基数字段**：**索引字段的基数是指字段中不同值的数量**。高基数字段可以提供更好的过滤能力，因此在建立索引时应优先考虑选择高基数字段。
    
3. 避免过多索引：不要在每个字段上都创建索引，**过多的索引会增加数据维护的成本，同时也会增加写操作的开销**。只创建必要的索引，避免不必要的冗余索引。
    
4. **组合索引**：对于经常一起查询的字段，可以将它们组合在一个索引中，形成组合索引。组合索引可以减少索引数量，提高索引的覆盖度，从而提高查询性能。
    
5. 考虑**查询顺序**：索引字段的顺序也很重要。对于联合索引，要考虑查询时的字段顺序，将经常用于过滤条件的字段放在前面，以提高索引的效率。
    
6. 不要滥用前缀索引：前缀索引是指对字段的前几个字符进行索引，可以节省存储空间。但是过多地使用前缀索引可能会导致索引选择不当，影响查询性能。
    
7. 适当使用索引覆盖：索引覆盖是指查询只需要通过索引就能得到结果，不需要再回表查询数据行。适当使用索引覆盖可以减少数据库的IO操作，提高查询性能。
    
8. 定期维护索引：随着数据的插入、更新和删除，索引会产生碎片，影响查询性能。定期进行索引维护，例如重建索引或优化表，可以保持索引的高效性。
    

总的来说，索引的设计和建立需要综合考虑数据库的查询需求、数据量和硬件资源等因素。通过合理地设计和使用索引，可以显著提高数据库的查询性能和并发能力。但是过多或不必要的索引也会增加数据库的维护成本和写入性能，因此需要权衡好索引的数量和适用场景。

#### 索引优化
	1.  场景 order by ，join on
	2.  unique ，index
	3.  not null
	4.  联合索引

#### 索引失效情况

1. **使用函数、运算符或表达式**：当在查询中对索引列使用函数、运算符或表达式时，索引可能会失效。例如，`WHERE YEAR(timestamp_column) = 2023` 将会导致索引失效，因为函数会对索引列进行计算，使得无法直接利用索引进行检索。
    
2. **在索引列上使用 NOT、<> 或 IS NULL**：当在索引列上使用 `NOT`、`<>` 或 `IS NULL` 条件时，索引可能会失效。这是因为索引通常是按照升序或降序存储的，而这些条件可能导致 MySQL 不使用索引进行检索。
    
3. **模糊查询开头使用通配符**：在模糊查询中，如果通配符（例如 `%`）出现在查询的开头，索引可能会失效。例如，`WHERE name LIKE '%John'` 将会导致索引失效。
    
4. **联合索引中未使用第一个列**：在联合索引中，如果没有使用第一个列，而是从索引的中间列开始进行检索，索引可能会失效。
    
5. **查询返回行数过多**：当查询返回的行数较大时，数据库可能会决定放弃使用索引，因为全表扫描可能更为高效。
    
6. **数据分布不均匀**：如果索引列的数据分布极不均匀，例如某个值在数据中出现的频率非常高，索引可能会失效，因为数据库可能会选择全表扫描来查找数据。
    
7. **隐式类型转换**：如果在查询中进行了隐式类型转换，例如将字符串列与数字进行比较，索引可能会失效。
    
8. **大数据量的排序操作**：如果查询需要对大数据量的结果集进行排序，可能会选择不使用索引。

#### B树

**1、相同思想和策略**

从平衡二叉树、B树、B+树、B\*树总体来看它们的贯彻的思想是相同的，都是采用二分法和数据平衡策略来提升查找数据的速度；

**2、不同的方式对树的不断优化**

1、首先，为了保证树的节点均匀分布，所以在二叉树的基础上加上了平衡算法，就有了平衡二叉树。

2、为了减少树的高度，所以B树一个节点下面可以添加N个子节点，然后每个节点的大小限制在磁盘块容量大小，让节点只需要通过一次IO就能读取到所有数据，通过增加节点存储的数据减少了树的高度，而节点的数据变多并没有让IO次数变多。

3、B+树在B树的基础上，在查询的稳定性 和排序方面进行了优化，因为B+树所有的数据都会保存到叶子节点，然后所有叶子节点本身是有序的。

4、B\*树为了减少树在构建过程中节点的拆分、合并次数，所以在每个节点上都保存了旁边节点的指针，在节点需要进行拆分、合并时，优先从旁边节点挪数据，从而减少构建过程中节点拆分、合并的次数，提升了树的构建性能。

### 分库分表规则

分库分表是指将大型数据库拆分为多个小型数据库（分库）以及将大表拆分为多个小表（分表），以**实现数据库的水平扩展和提高数据库性能**。在进行分库分表时，需要考虑一些规则和注意事项，以保证数据一致性和查询性能。

1. 垂直拆分与水平拆分：在分库分表前，首先需要根据业务需求确定是采用垂直拆分还是水平拆分。**垂直拆分是指将不同业务功能的数据放在不同的库中**，如将用户信息、订单信息分开存储。**水平拆分是指将一个大表的数据拆分成多个小表**，如按照时间范围或按照某个字段进行拆分。
    
2. 数据划分规则：确定数据划分规则是分库分表的关键。在**进行水平拆分时，可以根据业务数据的特点选择合适的划分规则**，如按照日期范围、地理位置、用户ID 等划分。确保数据在拆分后能够均匀分布，避免热点数据的问题。
    
3. 一致性和跨库事务：分库分表后，可能需要处理分布在不同库中的数据一致性问题。对于涉及跨库的事务操作，需要考虑**使用分布式事务或两阶段提交等机制**来保证数据的一致性。
    
4. 分库分表工具：有一些开源的分库分表工具可供使用，如ShardingSphere、Vitess等。这些工具可以简化分库分表的实现过程，并提供一些额外的功能，如读写分离、负载均衡等。
    
5. 迁移和扩容：在分库分表后，可能需要进行数据迁移或扩容的操作。迁移数据时需要保证数据的完整性和一致性，同时需要考虑数据库的备份和恢复策略。
    
6. 优化查询：分库分表可能会增加查询的复杂性。在编写查询语句时，需要考虑如何优化查询性能，避免跨库查询和全表扫描的情况。
    

总的来说，分库分表是一种常用的数据库架构优化手段，可以有效提高数据库的性能和扩展性。但分库分表也会增加系统复杂性，需要在设计和实现过程中综合考虑数据一致性、查询性能和可扩展性等方面的问题。

### 存储引擎

MyISAM 和 InnoDB 是 MySQL 中两种常用的存储引擎（Storage Engine），用于管理数据的存储和访问。它们有不同的特点和适用场景。

1. MyISAM： MyISAM 是 MySQL 的默认存储引擎（在 MySQL 5.5.5 版本之前）。它以较简单的方式存储数据，对于读操作具有较好的性能，适用于大量的读操作和少量的写操作的场景。
    
    主要特点：
    
    - 不支持事务：MyISAM 不支持事务，这意味着它不支持事务的原子性、一致性、隔离性和持久性（ACID 特性）。
    - **表级锁**：MyISAM 使用表级锁，这意味着在执行写操作时会锁定整个表，可能导致并发写操作的性能瓶颈。
    - **全文索引**：MyISAM 支持全文索引，适用于全文搜索的场景。
    
    由于 MyISAM 不支持事务和使用表级锁，不建议在高并发、写操作频繁的业务场景中使用 MyISAM 引擎。
    
2. InnoDB： InnoDB 是 MySQL 中另一种常用的存储引擎。它支持事务和行级锁，提供了更好的数据完整性和并发性，适用于高并发和频繁写入的业务场景。
    
    主要特点：
    
    - **支持事务**：InnoDB 支持事务，允许用户实现事务的原子性、一致性、隔离性和持久性（ACID 特性）。
    - **行级锁**：InnoDB 使用行级锁，可以在并发读写操作时避免表级锁带来的性能瓶颈，提高了并发性能。
    - 外键支持：InnoDB 支持外键约束，可以保证数据的完整性。
    
    InnoDB 是 MySQL 5.5.5 版本及以后的默认存储引擎。对于大多数应用来说，InnoDB 引擎通常是更好的选择，特别是对于需要支持事务和并发写入的应用场景。
    

在选择存储引擎时，应根据应用的需求和特点来选择合适的引擎。对于读多写少的简单查询场景，MyISAM 可能会有更好的性能。而对于需要事务支持和高并发写入的应用，InnoDB 是更稳定和可靠的选择。

### 事务（Transaction）
1.  begin;
2.  commit;
3.  rollback;

当面试中涉及 MySQL 事务的问题时，通常会涵盖数据库事务的基本概念、事务的特性（ACID）、并发控制和隔离级别等方面。以下是一些可能出现在 MySQL 事务相关面试题中的问题：

1. 什么是数据库事务？ 回答：数据库事务是一组被视为单个逻辑单元的数据库操作，要么全部成功执行（提交），要么全部回滚（撤销），从而**确保数据的一致性和完整性**。
    
2. 事务的 ACID 特性是什么？
	1. 原子性（Atomicity）：事务是一个原子操作，要么全部执行成功，要么全部失败回滚，不存在部分执行的情况。如果事务中的任何一个操作失败，整个事务将被回滚，数据库状态回到事务开始前的状态。
	2. 一致性（Consistency）：事务执行前后，数据库的数据应该保持一致性。这意味着在事务执行过程中，数据库从一个合法状态转换到另一个合法状态，不会破坏数据的完整性和约束条件。
	3. 隔离性（Isolation）：多个事务可以并发地同时访问数据库，但每个事务的操作对其他事务应该是隔离的，一个事务的操作不应该影响其他事务的执行结果。隔离性通过事务的隔离级别来控制，不同的隔离级别提供了不同的并发控制机制。
	4. 持久性（Durability）：一旦事务提交成功，对数据库的修改就是永久性的，即使在系统崩溃后也不会丢失。
    
3. MySQL 默认使用的事务隔离级别是什么？ 回答：MySQL 默认使用的事务隔离级别是 REPEATABLE READ。这是为了保证事务的可重复读性，即在同一个事务中多次读取同一数据，得到的结果都是一样的。
    
4. 什么是脏读（Dirty Read）、幻读（Phantom Read）和不可重复读（Non-repeatable Read）？ 回答：这些都是并发事务执行时可能出现的问题。
    
    - 脏读是指一个事务读取了另一个事务未提交的数据。
    - 幻读是指一个事务读取了另一个事务已提交的新增数据，导致之前的查询结果和之后的查询结果不一致。
	    - 使用 SERIALIZABLE 隔离级别：
			`SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;`
	    - 使用锁定读（FOR UPDATE）：
			`SELECT * FROM table_name WHERE column_name = 'value' FOR UPDATE;`
    - 不可重复读是指一个事务内两次读取同一数据，但两次读取的结果不一致，可能是因为另一个并发事务修改了数据。
5. 如何解决并发事务的问题？ 回答：可以通过设置不同的事务隔离级别来解决并发事务的问题。MySQL 支持四种事务隔离级别：READ UNCOMMITTED、READ COMMITTED、REPEATABLE READ 和 SERIALIZABLE。每个隔离级别都有不同的特点和用途，可以根据实际场景选择合适的隔离级别。
    

这些问题只是可能涉及 MySQL 事务的一部分，面试中可能会涵盖更多的细节和场景。在准备面试时，建议深入理解数据库事务的基本概念和 ACID 特性，以及各种隔离级别的特点和应用场景。

### 事务隔离级别

在 MySQL 中，可以通过设置合适的事务隔离级别来解决脏读问题。事务隔离级别包括 READ UNCOMMITTED、READ COMMITTED、REPEATABLE READ 和 SERIALIZABLE。设置事务隔离级别为 READ COMMITTED 或更高级别，可以避免脏读的问题。

1. **READ UNCOMMITTED（读未提交）**：最低的隔离级别，事务可以读取未提交的数据。这种隔离级别可能会出现脏读、不可重复读和幻读问题。
2. **READ COMMITTED（读已提交）**：事务**只能读取已提交的数据，禁止脏读**。但仍可能出现不可重复读和幻读问题。
3. **REPEATABLE READ（可重复读）**：事务**开始时建立一个快照，保证在事务执行过程中可以多次读取同样的数据**，并阻止不可重复读。但仍可能出现幻读问题。
4. **SERIALIZABLE（串行化）**：最高的隔离级别，事务按顺序执行，避免了脏读、不可重复读和幻读问题。但并发性较差，可能导致性能问题。

设置事务隔离级别的方式为：
```sql
SET TRANSACTION ISOLATION LEVEL <isolation_level>;
```

### 锁机制

MySQL 的锁机制是**用于实现并发控制的重要组成部分**，确保在多个事务同时访问数据库时数据的一致性和完整性。MySQL 支持多种类型的锁，这些锁可以在事务执行过程中对数据进行加锁和解锁，以控制数据的访问权限。

#### 在以下情况下，锁算法会被广泛应用：

1. 并发事务处理：在多用户同时访问数据库时，可能会出现并发事务操作同一数据的情况。为了避免数据不一致性和冲突，需要使用锁算法对数据进行加锁，确保每个事务能够按照规定的顺序读取和修改数据。
2. 事务隔离级别：数据库系统通常支持多种事务隔离级别，如读未提交、读提交、可重复读和串行化。不同的事务隔离级别会使用不同的锁算法来实现对数据的并发控制。
3. 行级锁：行级锁是一种精细粒度的锁算法，它在某些情况下可以提高数据库的并发性能。在需要同时处理大量并发读写操作的情况下，行级锁是常用的并发控制方式。
4. 防止并发问题：并发访问数据库时，可能会出现一些并发问题，如丢失更新、脏读、不可重复读和幻读等。通过锁算法，可以避免这些并发问题，确保数据的正确性和完整性。
5. 优化查询性能：在某些情况下，数据库系统可以使用锁算法来优化查询性能。例如，通过间隙锁（Gap Lock）可以避免幻读问题。

总的来说，**锁算法在任何需要处理并发访问数据库的情况下都会用到**，它是确保数据库的数据一致性和并发性能的重要机制。数据库管理系统根据具体的事务隔离级别和锁粒度来选择合适的锁算法，以满足不同业务场景的需求。

#### 主要的锁类型包括：

1. **共享锁（Shared Lock，也称为读锁）**：
    - 允许多个事务同时持有共享锁，并且可以共享同一份数据。
    - 共享锁用于防止其他事务对数据进行修改，但允许其他事务读取数据。
    - 适用于并发读取的场景。
2. **排他锁（Exclusive Lock，也称为写锁）**：
    - 一次只能有一个事务持有排他锁。
    - 排他锁用于防止其他事务对数据进行读取和修改，保证只有一个事务能够修改数据。
    - 适用于并发写入的场景。

MySQL 中的锁可以通过以下方式进行管理：

1. 表级锁（Table-level Lock）：
    - 表级锁是最粗粒度的锁，对整个表进行加锁。
    - 使用 LOCK TABLES 语句可以对表进行加锁，防止其他事务对整个表进行读写操作。
    - 一般情况下，表级锁的并发性较差，会导致性能瓶颈。
2. **行级锁、记录锁（Row-level Lock）**：
    - 行级锁是最细粒度的锁，对数据库中的每一行数据进行加锁。
    - InnoDB 存储引擎支持行级锁，通过在事务中使用 SELECT ... FOR UPDATE 或 SELECT ... LOCK IN SHARE MODE 可以对查询的行进行加锁。
    - 行级锁的并发性较好，可以减少锁的竞争，提高数据库的并发性能。
3. 页级锁（Page-level Lock）：
    - 页级锁对数据库中的每一页数据进行加锁。
    - 在某些存储引擎中可能会使用页级锁作为粒度介于表级锁和行级锁之间的锁。
4. **间隙锁（Gap Locking）**： 
    间隙锁用于保护范围查询，防止其他事务在查询范围内插入新的数据，避免幻读问题。间隙锁在 InnoDB 存储引擎中实现。

使用合适的锁机制可以确保并发事务之间的数据访问是正确、安全和有效的。在实际开发中，需要根据业务需求和数据库引擎的特性选择适合的锁策略，以保证数据库的性能和数据完整性。

#### 临时键锁 和 间隙锁

在 MySQL 中，临时键锁（Temporary Key Lock）和间隙锁（Gap Lock）都是 InnoDB 存储引擎内部用于支持不同事务隔离级别的一种锁机制。它们的作用是确保多个事务并发执行时，保持数据的一致性和避免并发问题，特别是针对范围查询的情况。

1. **临时键锁（Temporary Key Lock）**：
    - 临时键锁是 InnoDB 存储引擎在执行特定类型的 SQL 查询时自动生成的锁。它主要用于支持不同的事务隔离级别，特别是在 REPEATABLE READ 和 SERIALIZABLE 隔离级别下，用于避免幻读问题。
    - **当执行 WHERE 子句带有范围条件的 SELECT 查询时**，InnoDB 会为查询的范围键值创建临时键锁，保护这个范围内的键值不会被其他事务插入。
    - 临时键锁是 InnoDB 存储引擎内部的一种锁，它并不是由用户显式创建的，也无法直接查看。
2. **间隙锁（Gap Lock）**：
    - 间隙锁是 InnoDB 存储引擎用于锁定范围查询的一种锁机制。它主要用于在**事务执行范围查询时，锁定查询范围内的间隙，防止其他事务在这个间隙内插入新的数据**。
    - 间隙锁的作用是避免幻读问题，即当一个事务在查询某一范围的数据时，另一个事务在这个范围内插入了新的数据，导致前一个事务再次查询时出现新插入的数据。
    - 间隙锁是 InnoDB 存储引擎的一种锁，它是基于范围的锁定，用于保护范围查询的数据完整性。

需要注意的是，临时键锁和间隙锁是 InnoDB 存储引擎内部的锁机制，在执行特定类型的查询时自动生成和管理，用户无法直接控制或查看这些锁。它们的目的是为了支持不同事务隔离级别下的数据一致性和并发控制。

#### 锁算法的动态产生和退化

在 MySQL 中，锁算法的动态产生和退化是指**在并发事务处理过程中，根据事务隔离级别和具体的查询操作，MySQL 存储引擎会智能地选择合适的锁类型，并根据锁冲突的情况进行动态调整，以保持数据的一致性和并发性能。** 下面更详细地说明锁算法的动态产生和退化过程：

1. 动态产生锁：
    - 记录锁（Record Lock）的产生：当一个事务对数据库表中的某一行数据进行修改或锁定时，MySQL 会生成记录锁，**确保其他事务无法同时修改或锁定该行**，从而保持数据的一致性。记录锁适用于对行级别的并发控制。
    - 间隙锁（Gap Lock）的产生：间隙锁用于保护范围查询，**防止其他事务在查询范围内插入新的数据**。在执行带有范围条件的查询时，MySQL 可能会生成间隙锁，锁定查询范围内的间隙。间隙锁适用于对范围的并发控制。
2. 动态退化锁：
    - **间隙锁退化为表级锁**：当间隙锁无法满足查询条件时，可能会退化为表级锁。例如，在某些情况下，数据库可能需要锁定整个表来确保数据的一致性，这时间隙锁可能会退化为表级锁。
    - **记录锁退化为间隙锁**：在事务隔离级别为 `REPEATABLE READ` 或 `SERIALIZABLE` 时，MySQL 可能会将记录锁退化为间隙锁。例如，在执行带有范围条件的查询时，为了防止幻读，记录锁可能会退化为间隙锁来保护整个范围。
3. 锁冲突的处理：
    - 锁冲突是指多个事务之间由于需要对相同的数据资源加锁而产生的竞争。当多个事务同时请求对同一数据资源进行修改或锁定时，可能会发生锁冲突。MySQL 存储引擎会检测锁冲突，并根据锁冲突的情况来调整锁的产生和退化，以避免死锁的发生，保持数据的一致性。

总的来说，MySQL 的锁算法在执行查询操作时会根据事务隔离级别和锁冲突的情况智能地选择合适的锁类型，并在必要时进行锁的退化，以保证数据库的一致性和并发性能。这些调整是数据库存储引擎内部根据具体情况进行管理的，用户无需显式干预。在设计数据库结构和编写查询语句时，应该了解锁算法的特性，避免并发问题，并根据业务需求选择合适的事务隔离级别和锁粒度。

#### 几种常用的锁机制及其使用方式：

1. 共享锁（Shared Lock）： 共享锁用于保证多个事务可以同时读取一份数据，但不允许并发事务修改数据。可以通过 **`LOCK IN SHARE MODE`** 语句在 SELECT 查询中使用共享锁：
    
    ```sql
SELECT * FROM table_name WHERE column_name = 'value' LOCK IN SHARE MODE;
    ```
    
    当事务持有共享锁时，其他事务也可以持有共享锁，但不能持有排他锁。
    
2. 排他锁（Exclusive Lock）： 排他锁用于保证只有一个事务可以修改数据，其他事务不能读取和修改数据。可以通过 **`FOR UPDATE`** 语句在 SELECT 查询中使用排他锁：
    
    ```sql
SELECT * FROM table_name WHERE column_name = 'value' FOR UPDATE;
    ```
    
    当事务持有排他锁时，其他事务不能持有共享锁或排他锁。
    
3. 行级锁（Row-level Lock）： 行级锁是最细粒度的锁，它对数据库中的每一行数据进行加锁。在 InnoDB 存储引擎中，默认就是使用行级锁。在事务中，可以通过 `SELECT ... FOR UPDATE` 或 `SELECT ... LOCK IN SHARE MODE` 语句对查询的行进行加锁。
    
4. 表级锁（Table-level Lock）： 表级锁是最粗粒度的锁，它对整个表进行加锁。可以通过 `LOCK TABLES` 和 `UNLOCK TABLES` 语句对表进行加锁和解锁。
    
```sql
LOCK TABLES table_name [AS alias] {READ | WRITE}; -- 执行操作... UNLOCK TABLES;
```
    
    表级锁的使用较少，一般情况下推荐使用行级锁。
    

需要注意的是，在使用锁机制时，要注意避免死锁（Deadlock）的情况。死锁是指两个或多个事务相互等待对方释放锁，导致无法继续执行的情况。为了避免死锁，需要合理地设计事务逻辑和锁的使用顺序。

#### 死锁（Deadlock）

死锁是在并发环境中发生的一种特殊情况，它指的是两个或多个事务相互持有对方所需要的资源，从而导致所有事务都无法继续执行，被永久地阻塞在等待对方释放资源的状态。简单来说，死锁是由于资源竞争导致的一种僵局，使得系统无法继续进行。

#### MySQL 实现应用层级锁

1. 乐观锁
	1. **添加版本字段**： 在你的数据表中，可以添加一个版本字段（也称为时间戳字段或版本号字段），用于记录数据的版本信息。每次更新数据时，都会同时更新版本字段的值。
	    
	2. **读取数据并比较版本**： 当要更新数据时，首先读取数据并获取当前的版本信息。然后，在更新之前，再次检查版本信息是否与之前读取的版本匹配。如果版本不匹配，说明在你读取数据后有其他操作更新了数据，你可以选择放弃或重试更新。
2. 悲观锁
	1. 核心思想是在进行数据操作之前，预先获取锁，以防止其他事务对同一数据进行并发修改。
	2. 行锁是一种常用的悲观锁实现方式。

### 高并发控制

MySQL 实现高并发控制主要依赖于其默认的并发控制机制：MVCC（Multi-Version Concurrency Control）。此外，还可以通过合理的数据库设计、优化查询语句、使用合适的索引以及调整系统配置等方式来保证高并发性能。以下是一些保证 MySQL 高并发控制的方法：

1. 使用 MVCC：MySQL 的默认存储引擎 InnoDB 支持 MVCC，通过版本号和快照读机制，实现了对数据的并发控制。MVCC 确保每个事务读取的数据是一致性的，并且可以同时执行多个并发事务，避免了读写冲突和死锁。
2. 优化查询语句：编写高效的查询语句是保证高并发性能的关键。避免全表扫描和复杂的 JOIN 操作，尽量使用索引来加速查询。通过 EXPLAIN 分析查询计划，优化慢查询，减少不必要的数据库开销。
3. 使用合适的索引：在表的设计阶段，根据查询需求和访问模式，选择合适的索引。索引可以显著提高数据检索的速度，减少全表扫描的开销。
4. 事务隔离级别：根据业务需求选择合适的事务隔离级别。在保证数据一致性的前提下，选择尽可能宽松的隔离级别，以减少锁的竞争和冲突，提高并发性能。
5. 适当分区和分表：对于大型数据库，可以考虑对数据进行分区或分表，将数据分散存储在不同的物理位置，以降低单个表的访问热点，提高并发性能。
6. 配置优化：根据硬件资源和数据库负载情况，适当调整 MySQL 的配置参数。调整缓冲区大小、线程池大小、并发连接数等参数，以满足高并发的需求。
7. 使用缓存：通过使用缓存技术，如 Redis、Memcached 等，将热点数据存放在内存中，减少对数据库的频繁访问，提高响应速度和并发能力。
8. 异步处理：将一些耗时的操作异步化，比如异步写入日志或处理后台任务，可以减少对数据库的直接压力，提高系统的并发能力。

综合上述方法，合理的数据库设计、优化查询语句、使用索引、调整配置以及使用缓存等措施可以有效地保证 MySQL 的高并发控制，使得数据库在面对大量并发访问时能够保持稳定、高效地运行。

#### MVCC 使用

在 MySQL 的 InnoDB 存储引擎中，MVCC（Multi-Version Concurrency Control）是默认的并发控制方式，用于**处理并发事务对数据库中数据的读取和修改操作**。MVCC 的使用主要涉及以下方面：

1. 事务隔离级别设置：MVCC 和事务隔离级别密切相关。在 MySQL 中，可以通过设置不同的事务隔离级别来决定 MVCC 的具体行为。常见的事务隔离级别包括 READ UNCOMMITTED、READ COMMITTED、REPEATABLE READ 和 SERIALIZABLE。
    
2. 读取操作：当一个事务执行查询操作时，它会使用自己的 Read-View 来读取数据。Read-View 确保该事务只能看到它开始之前已提交的数据，不会看到其他事务尚未提交的数据或者已经提交但对于该事务不可见的数据。
    
3. 数据修改：当一个事务执行修改操作（如插入、更新或删除）时，MySQL 不会直接对原始数据进行修改，而是会创建一份新的数据版本，并将新数据版本写入数据库中。同时，原始数据行会保留，并在新数据版本中记录对原始数据的修改。
    
4. 数据回滚：如果一个事务执行失败或被回滚，它对数据的修改不会立即生效，而是会将新数据版本标记为无效，不可见。这样其他事务在读取数据时不会看到这个事务的未提交修改。
    
5. 并发控制：**MVCC 通过版本号和 Read-View 来实现对数据的并发控制**。每个事务在开始时会有一个唯一的事务ID，新的数据版本会记录当前事务ID，而 **Read-View 会记录当前事务开始时的已提交事务ID范围**。这样可以确保每个事务只能读取到自己开始之前已提交的数据版本，避免读写冲突和幻读问题。
    

在使用 MVCC 时，开发人员一般不需要显式操作或配置。**MVCC 是 InnoDB 存储引擎的内部实现机制，由数据库管理系统自动管理并控制。** 开发人员只需要在需要的地方开始事务、执行读取和修改操作，以及在合适的时候提交或回滚事务即可。

### slow_query_log

`slow_query_log` 是 MySQL 数据库的一个参数，用于开启或关闭慢查询日志记录功能。慢查询日志记录了执行时间超过一定阈值的 SQL 查询语句，帮助开发人员或数据库管理员识别数据库中执行时间较长的查询，从而优化和改进数据库性能。

```sql
SHOW VARIABLES LIKE 'slow_query_log';
```

### processlist

在 MySQL 中，`SHOW PROCESSLIST` 是一个用于查看当前连接到数据库服务器的客户端进程（线程）列表的命令。它可以用于监视数据库中正在执行的查询和操作，了解当前数据库的运行情况和性能状况。

```sql
SHOW PROCESSLIST;
```


### SQL优化
 1. 尽量避免使用 NULL
 2. show processlist
 3. 读写分离
 4. in > between
 5. in > exists
 6. or > union 组合查询
 7. where 1=1 > 去掉
 8. where 联合索引 按顺序
 9. 避免隐式类型转换
 10. join 小表在前
 11. 用表 的 别名
 12. HAVING > where
 13. where 从左到右的顺序
 14. inset 多条合并插入
 15. order by null
 16. union > union all
 17. delete > truncate

### 参考文章：
1. [SQL优化](https://developer.aliyun.com/article/779151)
