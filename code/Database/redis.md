Redis是一种快速的键值存储数据库，支持多种数据类型。以下是Redis主要的数据类型及其使用场景：

### 数据类型及其使用
#### 1. 字符串 (String)：
    - 存储单个值，通常用于**缓存、计数器、分布式锁**等。
    - 使用场景：缓存数据、计数器、计量器、短期会话数据等。
#### 2. 列表 (List)：
    - 有序的字符串元素集合，支持在两端进行添加、删除操作，可以用作**队列或栈**。
    - 使用场景：**消息队列、任务队列、最新消息排行等功能(比如朋友圈的时间线)**等。
#### 3. 集合 (Set)：
    - **无序的**字符串元素集合，支持快速的添加、删除、查找操作，并能够对多个集合进行交集、并集、差集等操作。
    - 使用场景：**标签系统、用户关注列表、共同好友查找**等。
#### 4. 有序集合 (Sorted Set)：
    - 类似于集合，但每个元素都关联一个分数，用于进行排序。元素的唯一性通过成员的唯一性来保证。
    - 使用场景：**排行榜**、最热帖子、**优先级队列**等。

|常用命令格式|描述|
|---|---|
|**ZADD** key score member [score member …]|向集合添加元素|
|**ZREM** key member [member …]|移除集合中的元素|
|**ZSCORE** key member|得到元素的分数|
|**ZINCRBY** key increment member|增长元素的分数|
|**ZCARD** key|获得集合中元素的个数|
|**ZRANK** key member|成员按分值递减(从小到大)排列的排名|
|**ZRANGE** key start stop [WITHSCORES]|按score值递增(从小到大)排序，WITHSCORES返回分数|
|**ZRANGEBYSCORE** key max min [WITHSCORES]|返回分数范围内数据，按score值递增(从小到大)排序，WITHSCORES返回分数|
|**ZCOUNT** key min max|统计得到分数在min和max之间的元素个数|
|{ **ZREMRANGEBYRANK** key start stop }、{ **ZREMRANGEBYSCORE** key min max}|按照排名/分数范围删除元素|
|**ZREVRANK** key member|成员按分值递减(从大到小)排列的排名|
|**ZREVRANGE** key start stop [WITHSCORES]|按score值递增(从大到小)排序，WITHSCORES返回分数|
|**ZREVRANGEBYSCORE** key max min [WITHSCORES]|返回分数范围内数据，按score值递增(从大到小)排序，WITHSCORES返回分数|


#### 5. 哈希 (Hash)：
    - 存储字段和值的映射关系，适合存储对象或结构化数据。
    - 使用场景：**存储用户信息**、商品信息等复杂结构。
#### 6. 位图 (Bitmap)：
    - 位图数据结构，支持对单个位或多个位进行操作，适用于位运算场景。
    - 使用场景：统计用户活跃时间、用户签到信息等。
#### 7. 地理空间索引 (GeoSpatial)：
    - 存储地理位置信息，支持位置查询和附近位置查找。
    - 使用场景：地理位置服务、附近的人、商家等。
#### 8. HyperLogLog：
    - 用于近似计数的数据结构，可以高效地统计集合中不重复元素的数量。
    - 使用场景：基数统计、独立访客统计等。


1.  string
	1.  Set 
		1. 基本格式：\[业务名称]:\[数据名]:\[id]
		2. SetNX 不存在则设置 
			1. 用来分布式锁
			2. Del 释放锁
		3. Setex 设置过期时间 分布式锁常用
	3.  incr incrby decr decrby

### 有序集合（Sorted Set）的编码方式

在Redis中，有序集合（Sorted Set）的编码方式取决于存储的元素数量和元素的大小。Redis为有序集合定义了两种编码方式：

1. **ziplist（压缩列表）编码**：
    - 当有序集合中的元素数量比较少，且每个元素的大小都比较小（小于64字节）时，Redis会采用ziplist编码。
    - **ziplist是一种紧凑的数据结构，将有序集合的所有元素紧密地存储在一块连续的内存区域中**，以节省内存空间。
    - ziplist适用于规模较小的有序集合，它在节省内存的同时，对于小型数据集合的读写操作也更为高效。
2. **skiplist（跳跃表）编码**：
    - 当有序集合中的元素数量较多，或者单个元素的大小较大（大于64字节），Redis会采用skiplist编码。
    - **skiplist是一种基于链表的数据结构，通过维护多层索引，可以实现快速的查找、插入和删除操作。**
    - skiplist适用于较大规模的有序集合，尽管相比ziplist会占用更多的内存，但是它在处理大型数据集合的读写操作上表现较为优秀。

Redis会根据有序集合的大小和元素的大小自动选择合适的编码方式。此外，需要注意的是，一旦有序集合的大小超过某个阈值（由配置选项`zset-max-ziplist-entries`和`zset-max-ziplist-value`决定），Redis就会从ziplist编码转换为skiplist编码。

控制有序集合（Sorted Set）使用ziplist（压缩列表）编码时的限制条件。
1. `zset-max-ziplist-entries`：
    - 默认值：128
    这个选项指定了有序集合在使用ziplist编码时，ziplist所能容纳的最大元素数量。当有序集合的元素数量超过这个限制时，Redis会自动将其转换为skiplist编码。
2. `zset-max-ziplist-value`：
    - 默认值：64
    这个选项指定了有序集合在使用ziplist编码时，单个元素的最大大小（以字节为单位）。当有序集合中的任何一个元素大小超过这个限制时，Redis会自动将其转换为skiplist编码。

对于用户来说，无需手动干预有序集合的编码方式，Redis会自动管理和优化编码方式以达到最佳性能和内存效率。

#### redis zset 为什么不用 b+树

1. **性能需求**：Redis的设计目标之一是追求极致的性能和低延迟。跳跃表的查询、插入和删除操作都可以在O(log N)的时间复杂度内完成，这对于Redis来说已经足够高效。
    
2. **内存效率**：B+树在内存中需要较多的额外空间用于节点管理和索引维护。跳跃表在空间利用上更为紧凑，适合在内存中存储。
    
3. **简单性**：跳跃表相对于B+树来说实现相对简单，维护和扩展也更容易。这在保持高性能的同时，也降低了代码的复杂性和潜在的bug。
    
4. **有序性查询和范围操作**：跳跃表天生支持有序性查询和范围操作，适用于有序集合的使用场景。在这方面，跳跃表的设计更为直接。
    

虽然B+树也是一种常用的有序数据结构，适用于很多应用场景，但在Redis的特定用途下，跳跃表的设计更符合其高性能、低延迟以及简单性的要求。不同的数据结构有不同的适用场景和权衡，Redis根据其核心价值和设计目标，选择了跳跃表和哈希表的组合来实现有序集合。

### 内存管理

1. **内存分配器**： Redis使用自定义的内存分配器，称为jemalloc或者libc malloc，用于分配和管理内存。jemalloc是一个优化过的内存分配器，能够有效地管理Redis的内存，减少内存碎片，并提供更好的性能。
    
2. **分配器内存区域划分**： Redis将内存划分为不同的区域，分别用于不同的数据结构，如字符串、列表、哈希等。这种内存区域的划分可以提高内存使用效率，减少内存碎片。
    
3. **对象共享**： 在Redis中，许多数据结构对象可以共享一份相同的数据副本。例如，当多个键包含相同的值时，Redis可以让这些键共享同一个字符串对象。这样做可以节省内存，特别是在存储大量重复数据时。
    
4. **过期键删除**： Redis通过设置过期时间（TTL）来管理键的生命周期。一旦键过期，Redis会在适当的时候自动删除它，释放相应的内存。
    
5. **内存淘汰策略**：Redis使用内存淘汰策略来释放内存空间。当内存不足时，Redis会根据预定义的策略选择要删除的键，从而腾出更多的内存。
    
6. **内存压缩**： 当Redis使用ziplist编码存储小型数据结构时，它会尝试在不丢失功能的情况下进行内存压缩，以减少内存占用。
    
7. **RDB和AOF持久化**： 尽管持久化机制本身不是内存管理的一部分，但通过将数据写入磁盘并清除内存中的数据，持久化可以有效地释放内存，避免内存使用过多。
    

Redis的内存管理是非常灵活和高效的，它允许管理员根据具体的业务需求和硬件配置来进行调整，以获得最佳的性能和资源利用率。

#### Redis 删除策略

1. **惰性删除（Lazy Expire）**：当访问一个已过期的key时，Redis会删除这个key并返回"nil"。这种方式称为惰性删除，因为Redis只在需要访问时才会检查并删除过期的key。
    
2. **定期删除（定时删除，定时任务）**：Redis会在后台随机抽取一些过期的key，并删除它们。这个过程是定期执行的，可以使用配置参数来控制执行频率。
    
3. **定期删除+惰性删除**：在某些情况下，定期删除可能无法及时删除所有过期的key，因此惰性删除也会被用来确保过期key的删除。
    
4. **定时检查策略**：Redis会每隔一段时间检查一些key，如果发现这些key已过期，则删除它们。
    
5. **内存淘汰策略**：当Redis的内存使用达到一定限制时，会触发内存淘汰策略。这些策略会删除一些key，以腾出更多的内存空间。
    

常见的内存淘汰策略包括：

- LRU（Least Recently Used）默认：删除最近最少使用的key。
- LFU（Least Frequently Used）：删除使用频率最低的key。
- Random（随机）：随机选择要删除的key。

在Redis中，你可以通过以下配置参数来调整删除策略和行为：

- `expire`命令用于设置key的过期时间。
- `maxmemory`和`maxmemory-policy`配置参数用于控制内存使用和淘汰策略。

根据你的应用需求，你可以选择合适的策略来管理和删除key，以充分利用内存并保持良好的性能。

### 缓存常见问题

#### 缓存穿透
1. 拦截非法参数
2. 将数据库不存在的数据也缓存下来：缺点是会有额外的内存消耗，而且可能造成短期的不一致
3. 使用布隆过滤器,保证一般访问体验

#### 缓存雪崩

缓存雪崩是指在某个时间点，大量缓存失效导致请求直接落到后端数据库，从而引发数据库压力剧增的情况。

1. 给不同的key设置随机的TTL
2. 利用Redis集群的高可用性
3. 给缓存的业务添加降级限流策略
4. 给业务增加多级缓存

#### 缓存击穿

缓存击穿是指一个非常热点的key，在其过期的瞬间，恰好有大量并发请求访问该key，导致请求直接访问数据库。

1. 永不过期
2. 互斥锁：当发现缓存过期，需要从数据库获取数据时，先获取锁，获取锁之后才访问数据库；如果没有获取锁，则休眠一段时间再次重试在缓存中获取数据，没有的话，再次尝试获取锁；缺点是线程需要等待，性能会收到影响，而且可能有死锁的风险
2. 逻辑过期：将热key过期后的数据也缓存起来，作为老数据，当新数据失效时，返回老数据，通过子进程获取互斥锁，新数据放到缓存中，然后释放锁。其他的进程没有访问到老数据也没有获取到锁时，则直接返回老数据；解决了线程等待的问题，性能好，缺点是不保证一致性，有额外的内存，而且实现复杂

##### Singleflight

`Singleflight`的工作原理**基于共享锁和缓存**。当一个请求需要查询某个结果时，它首先检查该结果是否已经被缓存，如果没有，就进入`Singleflight`的机制。在这个机制中，**正在执行相同查询的其他请求会等待，直到第一个请求完成查询并将结果返回**。其他等待的请求会共享这个结果，避免了重复查询。

`Singleflight`的优点是：

- 减少了重复查询，避免了缓存击穿问题。
- 减轻了后端数据库或服务的并发压力，提高了系统的稳定性和性能。

```go
package main

import (
	"fmt"
	"golang.org/x/sync/singleflight"
	"time"
)

func main() {
	var sf singleflight.Group

	for i := 0; i < 10; i++ {
		go func() {
			val, _, _ := sf.Do("key", func() (interface{}, error) {
				// 模拟查询耗时
				time.Sleep(time.Second)
				return "result", nil
			})
			fmt.Println(val)
		}()
	}

	time.Sleep(5 * time.Second) // 等待所有请求完成
}
```

### redis常用命令

- fluchdb 清空

#### pipelines(管道)
- pipe := rdb.Pipeline()
- cmds, err := pipe.Exec(ctx)

#### redis事务
- 开启事务(multi) 命令入队 执行事务(exec)  取消事务：discard
- 事务会被放弃，所有命令都不会执行，但是这并**不会回滚已经执行的命令**

### Redis 数据一致性

1. AOF日志在重启时保证数据一致性
2. 事务保证操作的一致性
3. 主从复制或者Redis Cluster保证节点数据的一致性

#### Redis 持久化策略

1. **RDB（Redis Database）持久化**：
    - RDB是一种快照式持久化方式，它会将Redis在某个时间点的数据状态保存到磁盘上的RDB文件中。
    - 当启用RDB持久化时，Redis会**周期性地执行数据快照，将数据写入RDB文件**。管理员可以通过配置`save`指令来设置快照的触发条件，比如设置时间间隔和键的变化数。
    - RDB持久化的过程涉及将内存中的数据写入磁盘上的RDB文件，这将导致一定的IO操作。
    - RDB持久化适用于需要**定期备份数据**，并且对于数据的完整性和一致性要求较高的情况。
2. **AOF（Append Only File）持久化**：
    - AOF持久化通过**记录Redis的写操作命令**来保存数据状态。当Redis重新启动时，会按照记录的操作顺序重新执行命令，从而重建数据状态。
    - AOF持久化可以通过配置`appendonly`选项来启用，并且可以选择不同的同步策略：`always`、`everysec`和`no`。其中，`always`表示每个写操作都立即写入磁盘，`everysec`表示每秒写入一次磁盘，`no`表示交由操作系统决定何时写入磁盘。
    - AOF持久化适用于需要**更加持久和实时的数据保护**，但相对于RDB持久化，AOF持久化的文件通常会更大。
3. 持久化配置优化：
	1. 用来做缓存的Redis实例，尽量不要开启持久化功能
	2. 建议关闭RDB，只使用AOF持久化
	3. 利用脚本定期在Slave节点做RDB，实现数据备份
	4. 设置合理的`rewrite`阈值，避免频繁`bgrewrite`
	5. 配置`no-appendfsync-on-rewrite=yes`，禁止在`rewrite`期间做AOF，避免因AOF引起的阻塞

管理员可以根据自己的需求选择合适的持久化策略，也可以同时启用两种持久化方式，以提供更高的数据安全性。同时，Redis还支持在特定条件下（如Redis在后台运行时、主从同步时）自动执行AOF重写和RDB压缩，以优化持久化文件的大小和加载速度。持久化策略的选择应根据具体的应用场景、性能要求和数据可靠性需求进行权衡。

### Redis 分布式

#### Redis 分布式架构
Redis在分布式架构中有几种常见的部署方式和拓扑结构，以满足不同规模和性能需求的应用场景。以下是一些常见的Redis分布式架构：

1. **主从复制（Master-Slave Replication）**：
    - 这是最简单的Redis分布式架构。一个Redis节点充当主节点（Master），负责写入数据，而其他Redis节点作为从节点（Slave），负责复制主节点的数据。
    - 从节点复制主节点的数据，可以提供数据备份、读取负载均衡和故障恢复的功能。当主节点出现故障时，可以将其中一个从节点升级为主节点以继续提供服务。
2. **哨兵模式（Sentinel）**：
    - 哨兵模式是在主从复制的基础上加入了监控和自动故障转移功能。一组哨兵节点负责监控所有主节点和从节点的状态。
    - 当主节点出现故障时，哨兵会自动选举新的主节点，并将从节点切换到新的主节点，从而实现自动故障转移。
3. **Redis Cluster**：
    - Redis Cluster是一种分布式数据存储方案，它将数据分布在多个节点上，并提供自动分区、数据复制和故障转移等功能。
    - Redis Cluster采用分片的方式将数据分布在多个节点上，每个节点负责一部分数据。每个节点还会有一到多个备份节点，负责数据的复制和故障转移。
4. **Twemproxy（nutcracker）**：
    - Twemproxy是Twitter开源的代理服务器，可以用于将多个Redis节点组织成一个逻辑集群，提供统一的访问接口。
    - Twemproxy可以用于解决数据分片和负载均衡的问题，将多个Redis节点组合在一起，作为一个虚拟的Redis数据库对外提供服务。

这些分布式架构在实际应用中可以根据具体的需求进行选择和组合。主从复制和哨兵模式适用于小规模的高可用部署，而Redis Cluster则适用于大规模的高可用和高性能场景。Twemproxy则适合用于将多个Redis节点组合在一起，构建逻辑集群提供服务。根据业务需求、性能需求和数据复杂性，选择合适的Redis分布式架构是非常重要的。

#### Redis 分布式锁

Redis分布式锁是一种基于Redis的分布式系统中用于实现并发控制的锁机制。在分布式环境中，多个进程或线程可能会同时对共享资源进行访问，分布式锁的目的是确保在同一时刻只有一个进程或线程能够获取锁，从而保证数据的一致性和避免并发冲突。

1. 高并发下的超卖问题
2. [redsync/v4](https://github.com/go-redsync/redsync)
	1. 使用 SetNX(key string, value interface{}, expiration time.Duration) 实现分布式锁
	2. 加入 random(uuid) 保证 unlock 的是相应的锁。
	3. 开个后台线程，延长锁的时间。
	4. 使用 lua 脚本保证原子性 
	5. Redlock 算法
		1. tfinal = texpect − tdelta
		2. 从大多数 Redis 节点（即：超过 Quorum>=N2+1 台）成功获取到了锁
		3. 获取锁失败了应该立即向所有 Redis 节点发起释放锁的操作
	6. Zookeeper

### 场景题

#### 有一个排行榜，用 zset，根据积分和时间来排序，**积分高的，时间最近的**拍前面，怎么实现

```bash
ZADD leader 12 'time+number1' # 示例：插入成员及分数
ZREVRANGE leader 0 -1 # 获取整个排行榜
zincrby leader 2 'time+number1' # 增长成员的分数
```

如果是根据积分和时间来排序，**积分高的，时间最远的**拍前面

```bash
ZADD leader -12 '-time+number1' # 示例：插入成员及分数
ZRANGE leader 0 -1 # 获取整个排行榜
zincrby leader -2 '-time+number1' # 增长成员的分数
```

#### 同时有很多个 redis 请求，怎么优化

1. **连接池管理**： 使用连接池来管理Redis连接，避免每次请求都重新建立连接。连接池可以减少连接的创建和销毁开销，提高连接的复用率。
    
2. **Pipeline批处理**： 使用Redis的Pipeline机制，将多个命令一次性发送到服务器，减少网络往返的延迟。这在需要执行多个命令的情况下可以显著提高性能。
    
3. **多线程/协程**： 在支持多线程或协程的环境中，可以使用多线程或协程来处理并发的Redis请求。每个线程/协程可以负责处理一部分请求，从而提高并发性能。
    
4. **分片**： 将数据分散到多个Redis实例或集群中，每个实例或集群负责处理一部分数据。这样可以将请求在不同的实例/集群之间分布，提高整体的并发性能。
    
5. **使用缓存**： 合理使用缓存来减少对Redis的频繁请求。将一些热点数据缓存在内存中，避免重复的读取操作。
    
6. **合并请求**： 如果多个请求需要获取相同的数据，可以尝试合并这些请求，将多个查询合并为一个，从而减少请求次数。
    
7. **高性能客户端**： 选择高性能的Redis客户端库，一些客户端库支持连接池、Pipeline等特性，可以提高并发性能。
    
8. **减少不必要的操作**： 在请求中避免不必要的操作，比如频繁的读写相同的数据，可以减少对Redis的负担。
    
9. **优化Redis配置**： 根据具体的应用场景，调整Redis的配置参数，如最大连接数、最大客户端数、缓冲区大小等，以适应高并发情况。
    
10. **监测和调优**： 使用监测工具对Redis的性能进行实时监测，并根据监测结果进行调优，及时发现并解决性能瓶颈。

### 参考文章：
1. [分布式锁：使用 Redis 实现](https://pandaychen.github.io/2020/06/01/REDIS-DISTRIBUTED-LOCK/)
2. [Golang中的本地锁和分布式锁](https://www.xiaoyeshiyu.com/post/9e4b.html)
3. [Redis学习笔记之实用篇](https://www.xiaoyeshiyu.com/post/c187.html)
4. [Redis基本数据类型代码示例](https://www.cnblogs.com/jiujuan/p/17215125.html)
5. [Redis使用详解](https://mynamelancelot.github.io/nosql/redis.html)