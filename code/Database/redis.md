Redis是一种快速的键值存储数据库，支持多种数据类型。以下是Redis主要的数据类型及其使用场景：

1. 字符串 (String)：
    - 存储单个值，通常用于**缓存、计数器、分布式锁**等。
    - 使用场景：缓存数据、计数器、计量器、短期会话数据等。
2. 列表 (List)：
    - 有序的字符串元素集合，支持在两端进行添加、删除操作，可以用作**队列或栈**。
    - 使用场景：**消息队列、任务队列、最新消息排行等功能(比如朋友圈的时间线)**等。
3. 集合 (Set)：
    - **无序的**字符串元素集合，支持快速的添加、删除、查找操作，并能够对多个集合进行交集、并集、差集等操作。
    - 使用场景：**标签系统、用户关注列表、共同好友查找**等。
4. 有序集合 (Sorted Set)：
    - 类似于集合，但每个元素都关联一个分数，用于进行排序。元素的唯一性通过成员的唯一性来保证。
    - 使用场景：**排行榜**、最热帖子、**优先级队列**等。
5. 哈希 (Hash)：
    - 存储字段和值的映射关系，适合存储对象或结构化数据。
    - 使用场景：**存储用户信息**、商品信息等复杂结构。
6. 位图 (Bitmap)：
    - 位图数据结构，支持对单个位或多个位进行操作，适用于位运算场景。
    - 使用场景：统计用户活跃时间、用户签到信息等。
7. 地理空间索引 (GeoSpatial)：
    - 存储地理位置信息，支持位置查询和附近位置查找。
    - 使用场景：地理位置服务、附近的人、商家等。
8. HyperLogLog：
    - 用于近似计数的数据结构，可以高效地统计集合中不重复元素的数量。
    - 使用场景：基数统计、独立访客统计等。


1.  string
	1.  Set 
		1. 基本格式：\[业务名称]:\[数据名]:\[id]
		2. SetNX 不存在则设置 
			1. 用来分布式锁
			2. Del 释放锁
		3. Setex 设置过期时间 分布式锁常用
	3.  incr incrby decr decrby

### 有序集合（Sorted Set）的编码方式

在Redis中，有序集合（Sorted Set）的编码方式取决于存储的元素数量和元素的大小。Redis为有序集合定义了两种编码方式：

1. **ziplist（压缩列表）编码**：
    - 当有序集合中的元素数量比较少，且每个元素的大小都比较小（小于64字节）时，Redis会采用ziplist编码。
    - ziplist是一种紧凑的数据结构，将有序集合的所有元素紧密地存储在一块连续的内存区域中，以节省内存空间。
    - ziplist适用于规模较小的有序集合，它在节省内存的同时，对于小型数据集合的读写操作也更为高效。
2. **skiplist（跳跃表）编码**：
    - 当有序集合中的元素数量较多，或者单个元素的大小较大（大于64字节），Redis会采用skiplist编码。
    - skiplist是一种基于链表的数据结构，通过维护多层索引，可以实现快速的查找、插入和删除操作。
    - skiplist适用于较大规模的有序集合，尽管相比ziplist会占用更多的内存，但是它在处理大型数据集合的读写操作上表现较为优秀。

Redis会根据有序集合的大小和元素的大小自动选择合适的编码方式。此外，需要注意的是，一旦有序集合的大小超过某个阈值（由配置选项`zset-max-ziplist-entries`和`zset-max-ziplist-value`决定），Redis就会从ziplist编码转换为skiplist编码。

控制有序集合（Sorted Set）使用ziplist（压缩列表）编码时的限制条件。
1. `zset-max-ziplist-entries`：
    - 默认值：128
    这个选项指定了有序集合在使用ziplist编码时，ziplist所能容纳的最大元素数量。当有序集合的元素数量超过这个限制时，Redis会自动将其转换为skiplist编码。
2. `zset-max-ziplist-value`：
    - 默认值：64
    这个选项指定了有序集合在使用ziplist编码时，单个元素的最大大小（以字节为单位）。当有序集合中的任何一个元素大小超过这个限制时，Redis会自动将其转换为skiplist编码。

对于用户来说，无需手动干预有序集合的编码方式，Redis会自动管理和优化编码方式以达到最佳性能和内存效率。

### redis常用命令

- fluchdb 清空

### pipelines(管道)
- pipe := rdb.Pipeline()
- cmds, err := pipe.Exec(ctx)

### redis事务
- 不保证原子性
- 开启事务(multi) 命令入队 执行事务(exec)  取消事务：discard

### redis持久化
- rdb方式（redis database）
	- 先将数据读取到一个临时文件，持久化都结束了，再替换上个版本的持久化文件
	- 不进行i/o操作
	- 可能存在数据丢失
- aof方式(append only file)
	- 将所有命令都记录下来，恢复的时候再把所有命令都全部执行一遍。
	- 修复速度慢
		- aof 默认文件追加，文件会越来越大，如果文件太大，fork一个新的进程进行重写
- 持久化配置优化：
	1. 用来做缓存的Redis实例，尽量不要开启持久化功能
	2. 建议关闭RDB，只使用AOF持久化
	3. 利用脚本定期在Slave节点做RDB，实现数据备份
	4. 设置合理的`rewrite`阈值，避免频繁`bgrewrite`
	5. 配置`no-appendfsync-on-rewrite=yes`，禁止在`rewrite`期间做AOF，避免因AOF引起的阻塞


### 缓存穿透
1. 拦截非法参数
2. 将数据库不存在的数据也缓存下来：缺点是会有额外的内存消耗，而且可能造成短期的不一致
3. 使用布隆过滤器,保证一般访问体验

### 缓存雪崩
1. 给不同的key设置随机的TTL
2. 利用Redis集群的高可用性
3. 给缓存的业务添加降级限流策略
4. 给业务增加多级缓存

### 缓存击穿
1. 永不过期
2. 互斥锁：当发现缓存过期，需要从数据库获取数据时，先获取锁，获取锁之后才访问数据库；如果没有获取锁，则休眠一段时间再次重试在缓存中获取数据，没有的话，再次尝试获取锁；缺点是线程需要等待，性能会收到影响，而且可能有死锁的风险
2. 逻辑过期：将热key过期后的数据也缓存起来，作为老数据，当新数据失效时，返回老数据，通过子进程获取互斥锁，新数据放到缓存中，然后释放锁。其他的进程没有访问到老数据也没有获取到锁时，则直接返回老数据；解决了线程等待的问题，性能好，缺点是不保证一致性，有额外的内存，而且实现复杂

### 三种集群方案

- 主从复制模式
	- 一个是读写分离，分担 "master" 的读写压力
	- 一个是方便做容灾恢复
- Sentinel（哨兵）模式
	- 主从可以自动切换，系统更健壮，可用性更高
- Cluster 模式
	- 所有的 redis 节点彼此互联(PING-PONG机制)，内部使用二进制协议优化传输速度和带宽。
	- 节点的 fail 是通过集群中超过半数的节点检测失效时才生效。
	- 客户端与 Redis 节点直连，不需要中间代理层.客户端不需要连接集群所有节点，连接集群中任何一个可用节点即可。

### Redis分布式锁
1. 高并发下的超卖问题
2. [redsync/v4](https://github.com/go-redsync/redsync)
	1. 使用 SetNX(key string, value interface{}, expiration time.Duration) 实现分布式锁
	2. 加入 random(uuid) 保证 unlock 的是相应的锁。
	3. 开个后台线程，延长锁的时间。
	4. 使用 lua 脚本保证原子性 
	5. Redlock 算法
		1. tfinal = texpect − tdelta
		2. 从大多数 Redis 节点（即：超过 Quorum>=N2+1 台）成功获取到了锁
		3. 获取锁失败了应该立即向所有 Redis 节点发起释放锁的操作
	6. Zookeeper


1. [# 分布式锁：使用 Redis 实现](https://pandaychen.github.io/2020/06/01/REDIS-DISTRIBUTED-LOCK/)
2. [# Golang中的本地锁和分布式锁](https://www.xiaoyeshiyu.com/post/9e4b.html)
3. [# Redis学习笔记之实用篇](https://www.xiaoyeshiyu.com/post/c187.html)
4. [# Redis基本数据类型代码示例](https://www.cnblogs.com/jiujuan/p/17215125.html)