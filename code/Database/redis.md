Redis是一种快速的键值存储数据库，支持多种数据类型。以下是Redis主要的数据类型及其使用场景：

1. 字符串 (String)：
    - 存储单个值，通常用于**缓存、计数器、分布式锁**等。
    - 使用场景：缓存数据、计数器、计量器、短期会话数据等。
2. 列表 (List)：
    - 有序的字符串元素集合，支持在两端进行添加、删除操作，可以用作**队列或栈**。
    - 使用场景：**消息队列、任务队列、最新消息排行等功能(比如朋友圈的时间线)**等。
3. 集合 (Set)：
    - **无序的**字符串元素集合，支持快速的添加、删除、查找操作，并能够对多个集合进行交集、并集、差集等操作。
    - 使用场景：**标签系统、用户关注列表、共同好友查找**等。
4. 有序集合 (Sorted Set)：
    - 类似于集合，但每个元素都关联一个分数，用于进行排序。元素的唯一性通过成员的唯一性来保证。
    - 使用场景：**排行榜**、最热帖子、**优先级队列**等。
5. 哈希 (Hash)：
    - 存储字段和值的映射关系，适合存储对象或结构化数据。
    - 使用场景：**存储用户信息**、商品信息等复杂结构。
6. 位图 (Bitmap)：
    - 位图数据结构，支持对单个位或多个位进行操作，适用于位运算场景。
    - 使用场景：统计用户活跃时间、用户签到信息等。
7. 地理空间索引 (GeoSpatial)：
    - 存储地理位置信息，支持位置查询和附近位置查找。
    - 使用场景：地理位置服务、附近的人、商家等。
8. HyperLogLog：
    - 用于近似计数的数据结构，可以高效地统计集合中不重复元素的数量。
    - 使用场景：基数统计、独立访客统计等。


1.  string
	1.  Set 
		1. 基本格式：\[业务名称]:\[数据名]:\[id]
		2. SetNX 不存在则设置 
			1. 用来分布式锁
			2. Del 释放锁
		3. Setex 设置过期时间 分布式锁常用
	3.  incr incrby decr decrby

### 内存管理

1. **内存分配器**： Redis使用自定义的内存分配器，称为jemalloc或者libc malloc，用于分配和管理内存。jemalloc是一个优化过的内存分配器，能够有效地管理Redis的内存，减少内存碎片，并提供更好的性能。
    
2. **分配器内存区域划分**： Redis将内存划分为不同的区域，分别用于不同的数据结构，如字符串、列表、哈希等。这种内存区域的划分可以提高内存使用效率，减少内存碎片。
    
3. **对象共享**： 在Redis中，许多数据结构对象可以共享一份相同的数据副本。例如，当多个键包含相同的值时，Redis可以让这些键共享同一个字符串对象。这样做可以节省内存，特别是在存储大量重复数据时。
    
4. **过期键删除**： Redis通过设置过期时间（TTL）来管理键的生命周期。一旦键过期，Redis会在适当的时候自动删除它，释放相应的内存。
    
5. **内存淘汰策略**：Redis使用内存淘汰策略来释放内存空间。当内存不足时，Redis会根据预定义的策略选择要删除的键，从而腾出更多的内存。
    
6. **内存压缩**： 当Redis使用ziplist编码存储小型数据结构时，它会尝试在不丢失功能的情况下进行内存压缩，以减少内存占用。
    
7. **RDB和AOF持久化**： 尽管持久化机制本身不是内存管理的一部分，但通过将数据写入磁盘并清除内存中的数据，持久化可以有效地释放内存，避免内存使用过多。
    

Redis的内存管理是非常灵活和高效的，它允许管理员根据具体的业务需求和硬件配置来进行调整，以获得最佳的性能和资源利用率。

#### 内存淘汰策略

Redis使用内存淘汰策略来处理内存不足的情况，当系统的可用内存接近上限时，Redis会根据预定义的淘汰策略从数据集中选择一些键（key）进行删除，以释放内存空间。以下是Redis支持的主要内存淘汰策略：

1. **Noeviction（不淘汰策略）**：
    
    - 默认情况下，Redis使用这个策略。当内存不足以容纳新写入数据时，Redis会直接返回错误信息，拒绝新的写入请求，此时需要外部采取措施来增加可用内存。
2. **Allkeys-LRU（最近最少使用）**：
    
    - Redis会在所有键中选择最近最少使用的键进行淘汰。
    - 这是一个相对简单的策略，适用于清理长时间没有使用的数据。
3. **Allkeys-LFU（最不经常使用）**：
    
    - Redis会在所有键中选择使用频率最低的键进行淘汰。
    - 这个策略适用于希望保留热门数据，而删除不常用数据的场景。
4. **Volatile-LRU（带过期时间的最近最少使用）**：
    
    - Redis会在设置了过期时间的键中选择最近最少使用的键进行淘汰。
    - 这个策略通常用于缓存场景，保留最常用的缓存数据。
5. **Volatile-LFU（带过期时间的最不经常使用）**：
    
    - Redis会在设置了过期时间的键中选择使用频率最低的键进行淘汰。
6. **Volatile-TTL（带过期时间的TTL淘汰）**：
    
    - Redis会在设置了过期时间的键中，选择剩余过期时间最短的键进行淘汰。

这些内存淘汰策略允许Redis在内存不足时根据业务需求选择最合适的数据淘汰方式，以保证系统的稳定性和性能。管理员可以通过配置`maxmemory-policy`选项来选择所需的淘汰策略。另外，还可以通过设置`maxmemory`选项来限制Redis使用的最大内存量，当达到这个限制时，淘汰策略将会被触发。

#### 有序集合（Sorted Set）的编码方式

在Redis中，有序集合（Sorted Set）的编码方式取决于存储的元素数量和元素的大小。Redis为有序集合定义了两种编码方式：

1. **ziplist（压缩列表）编码**：
    - 当有序集合中的元素数量比较少，且每个元素的大小都比较小（小于64字节）时，Redis会采用ziplist编码。
    - ziplist是一种紧凑的数据结构，将有序集合的所有元素紧密地存储在一块连续的内存区域中，以节省内存空间。
    - ziplist适用于规模较小的有序集合，它在节省内存的同时，对于小型数据集合的读写操作也更为高效。
2. **skiplist（跳跃表）编码**：
    - 当有序集合中的元素数量较多，或者单个元素的大小较大（大于64字节），Redis会采用skiplist编码。
    - skiplist是一种基于链表的数据结构，通过维护多层索引，可以实现快速的查找、插入和删除操作。
    - skiplist适用于较大规模的有序集合，尽管相比ziplist会占用更多的内存，但是它在处理大型数据集合的读写操作上表现较为优秀。

Redis会根据有序集合的大小和元素的大小自动选择合适的编码方式。此外，需要注意的是，一旦有序集合的大小超过某个阈值（由配置选项`zset-max-ziplist-entries`和`zset-max-ziplist-value`决定），Redis就会从ziplist编码转换为skiplist编码。

控制有序集合（Sorted Set）使用ziplist（压缩列表）编码时的限制条件。
1. `zset-max-ziplist-entries`：
    - 默认值：128
    这个选项指定了有序集合在使用ziplist编码时，ziplist所能容纳的最大元素数量。当有序集合的元素数量超过这个限制时，Redis会自动将其转换为skiplist编码。
2. `zset-max-ziplist-value`：
    - 默认值：64
    这个选项指定了有序集合在使用ziplist编码时，单个元素的最大大小（以字节为单位）。当有序集合中的任何一个元素大小超过这个限制时，Redis会自动将其转换为skiplist编码。

对于用户来说，无需手动干预有序集合的编码方式，Redis会自动管理和优化编码方式以达到最佳性能和内存效率。

### Redis 持久化策略

1. **RDB（Redis Database）持久化**：
    - RDB是一种快照式持久化方式，它会将Redis在某个时间点的数据状态保存到磁盘上的RDB文件中。
    - 当启用RDB持久化时，Redis会**周期性地执行数据快照，将数据写入RDB文件**。管理员可以通过配置`save`指令来设置快照的触发条件，比如设置时间间隔和键的变化数。
    - RDB持久化的过程涉及将内存中的数据写入磁盘上的RDB文件，这将导致一定的IO操作。
    - RDB持久化适用于需要**定期备份数据**，并且对于数据的完整性和一致性要求较高的情况。
2. **AOF（Append Only File）持久化**：
    - AOF持久化通过**记录Redis的写操作命令**来保存数据状态。当Redis重新启动时，会按照记录的操作顺序重新执行命令，从而重建数据状态。
    - AOF持久化可以通过配置`appendonly`选项来启用，并且可以选择不同的同步策略：`always`、`everysec`和`no`。其中，`always`表示每个写操作都立即写入磁盘，`everysec`表示每秒写入一次磁盘，`no`表示交由操作系统决定何时写入磁盘。
    - AOF持久化适用于需要**更加持久和实时的数据保护**，但相对于RDB持久化，AOF持久化的文件通常会更大。
3. 持久化配置优化：
	1. 用来做缓存的Redis实例，尽量不要开启持久化功能
	2. 建议关闭RDB，只使用AOF持久化
	3. 利用脚本定期在Slave节点做RDB，实现数据备份
	4. 设置合理的`rewrite`阈值，避免频繁`bgrewrite`
	5. 配置`no-appendfsync-on-rewrite=yes`，禁止在`rewrite`期间做AOF，避免因AOF引起的阻塞

管理员可以根据自己的需求选择合适的持久化策略，也可以同时启用两种持久化方式，以提供更高的数据安全性。同时，Redis还支持在特定条件下（如Redis在后台运行时、主从同步时）自动执行AOF重写和RDB压缩，以优化持久化文件的大小和加载速度。持久化策略的选择应根据具体的应用场景、性能要求和数据可靠性需求进行权衡。

- rdb方式（redis database）
	- 先将数据读取到一个临时文件，持久化都结束了，再替换上个版本的持久化文件
	- 不进行i/o操作
	- 可能存在数据丢失
- aof方式(append only file)
	- 将所有命令都记录下来，恢复的时候再把所有命令都全部执行一遍。
	- 修复速度慢
		- aof 默认文件追加，文件会越来越大，如果文件太大，fork一个新的进程进行重写
- 持久化配置优化：
	1. 用来做缓存的Redis实例，尽量不要开启持久化功能
	2. 建议关闭RDB，只使用AOF持久化
	3. 利用脚本定期在Slave节点做RDB，实现数据备份
	4. 设置合理的`rewrite`阈值，避免频繁`bgrewrite`
	5. 配置`no-appendfsync-on-rewrite=yes`，禁止在`rewrite`期间做AOF，避免因AOF引起的阻塞



### redis常用命令

- fluchdb 清空

### pipelines(管道)
- pipe := rdb.Pipeline()
- cmds, err := pipe.Exec(ctx)

### redis事务
- 不保证原子性
- 开启事务(multi) 命令入队 执行事务(exec)  取消事务：discard

### 缓存穿透
1. 拦截非法参数
2. 将数据库不存在的数据也缓存下来：缺点是会有额外的内存消耗，而且可能造成短期的不一致
3. 使用布隆过滤器,保证一般访问体验

### 缓存雪崩
1. 给不同的key设置随机的TTL
2. 利用Redis集群的高可用性
3. 给缓存的业务添加降级限流策略
4. 给业务增加多级缓存

### 缓存击穿
1. 永不过期
2. 互斥锁：当发现缓存过期，需要从数据库获取数据时，先获取锁，获取锁之后才访问数据库；如果没有获取锁，则休眠一段时间再次重试在缓存中获取数据，没有的话，再次尝试获取锁；缺点是线程需要等待，性能会收到影响，而且可能有死锁的风险
2. 逻辑过期：将热key过期后的数据也缓存起来，作为老数据，当新数据失效时，返回老数据，通过子进程获取互斥锁，新数据放到缓存中，然后释放锁。其他的进程没有访问到老数据也没有获取到锁时，则直接返回老数据；解决了线程等待的问题，性能好，缺点是不保证一致性，有额外的内存，而且实现复杂

### 三种集群方案

- 主从复制模式
	- 一个是读写分离，分担 "master" 的读写压力
	- 一个是方便做容灾恢复
- Sentinel（哨兵）模式
	- 主从可以自动切换，系统更健壮，可用性更高
- Cluster 模式
	- 所有的 redis 节点彼此互联(PING-PONG机制)，内部使用二进制协议优化传输速度和带宽。
	- 节点的 fail 是通过集群中超过半数的节点检测失效时才生效。
	- 客户端与 Redis 节点直连，不需要中间代理层.客户端不需要连接集群所有节点，连接集群中任何一个可用节点即可。

### Redis分布式锁
1. 高并发下的超卖问题
2. [redsync/v4](https://github.com/go-redsync/redsync)
	1. 使用 SetNX(key string, value interface{}, expiration time.Duration) 实现分布式锁
	2. 加入 random(uuid) 保证 unlock 的是相应的锁。
	3. 开个后台线程，延长锁的时间。
	4. 使用 lua 脚本保证原子性 
	5. Redlock 算法
		1. tfinal = texpect − tdelta
		2. 从大多数 Redis 节点（即：超过 Quorum>=N2+1 台）成功获取到了锁
		3. 获取锁失败了应该立即向所有 Redis 节点发起释放锁的操作
	6. Zookeeper


1. [# 分布式锁：使用 Redis 实现](https://pandaychen.github.io/2020/06/01/REDIS-DISTRIBUTED-LOCK/)
2. [# Golang中的本地锁和分布式锁](https://www.xiaoyeshiyu.com/post/9e4b.html)
3. [# Redis学习笔记之实用篇](https://www.xiaoyeshiyu.com/post/c187.html)
4. [# Redis基本数据类型代码示例](https://www.cnblogs.com/jiujuan/p/17215125.html)