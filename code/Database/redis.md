1.  string
	1.  Set 
		1. SetNX 不存在则设置 
			1. 用来分布式锁
			2. Del 释放锁
		2. Setex 设置过期时间 分布式锁常用
	3.  incr incrby decr decrby

3.  list列表类型
	1.  1,最新消息排行等功能(比如朋友圈的时间线) 2,消息队列

4.  hash哈希表类型
	1.  存储、读取、修改用户属性

5.  set集合类型
	1.  1、共同好友 2、利用唯一性,统计访问网站的所有独立ip 3、好友推荐时,根据tag求交集,大于某个阈值就可以推荐

6.  zset有序集合类型
	1.  1、排行榜 2、带权重的消息队列

7.  fluchdb 清空
8.  缓存雪崩
	1.  定时更新

9.  缓存穿透
	1.  拦截非法参数
	2.  存redis值，保证一般访问

10.  缓存击穿
	1.  永不过期


### redis事务
- 不保证原子性
- 开启事务(multi) 命令入队 执行事务(exec)  取消事务：discard

### redis持久化
- rdb方式（redis database）
	- 先将数据读取到一个临时文件，持久化都结束了，再替换上个版本的持久化文件
	- 不进行i/o操作
	- 可能存在数据丢失
- aof方式(append only file)
	- 将所有命令都记录下来，恢复的时候再把所有命令都全部执行一遍。
	- 修复速度慢
		- aof 默认文件追加，文件会越来越大，如果文件太大，fork一个新的进程进行重写

### 三种集群方案

- 主从复制模式
	- 一个是读写分离，分担 "master" 的读写压力
	- 一个是方便做容灾恢复
- Sentinel（哨兵）模式
	- 主从可以自动切换，系统更健壮，可用性更高
- Cluster 模式
	- 所有的 redis 节点彼此互联(PING-PONG机制)，内部使用二进制协议优化传输速度和带宽。
	- 节点的 fail 是通过集群中超过半数的节点检测失效时才生效。
	- 客户端与 Redis 节点直连，不需要中间代理层.客户端不需要连接集群所有节点，连接集群中任何一个可用节点即可。

### Redis分布式锁
1. 高并发下的超卖问题
2. [Redsync.go](https://github.com/hjr265/redsync.go)
	1. 使用 SetNX(key string, value interface{}, expiration time.Duration) 实现分布式锁
	2. 加入 random(uuid) 保证 unlock 的是相应的锁。
	3. 开个后台线程，延长锁的时间。
	4. 使用 lua 脚本保证原子性 